<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hoex5h.github.io/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hoex5h.github.io/" rel="alternate" type="text/html" />
  <updated>2025-01-23T06:21:53+00:00</updated>
  <id>https://hoex5h.github.io/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">hoeeeeeh | </title>
  

  
    <subtitle>HOEH 개발 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)</title>
      <link href="https://hoex5h.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)" rel="alternate" type="text/html" title="정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)" />
      <published>2025-01-16T02:20:00+00:00</published>
      <updated>2025-01-16T02:20:00+00:00</updated>
      <id>https://hoex5h.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)</id>
      <content type="html" xml:base="https://hoex5h.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)">&lt;p&gt;정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;다익스트라&quot;&gt;다익스트라&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;단일 시작점 최단 경로 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너비 우선 탐색과 유사&lt;/code&gt; 한 형태를 가진 알고리즘으로, 시작점에서 가까운 순서대로 정점을 방문한다. 다만 가중치(거리)가 있다보니 BFS 와 완전히 동일한 방식을 사용할 수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;우선순위-큐&quot;&gt;우선순위 큐&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐&lt;/code&gt; 를 활용한다. 우선순위 큐에 대한 자바스크립트의 구현은 &lt;a href=&quot;/우선순위_큐&quot;&gt;여기&lt;/a&gt; 를 참고하면 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(정점의 번호, 정점까지의 거리)&lt;/code&gt; 를 우선순위 큐에 넣어서 정점까지의 거리를 기준으로 우선순위 큐를 사용한다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점에서 다른 정점까지의 거리를 저장하는 배열&lt;/code&gt; 에 저장하면 된다. (간단히 dist 라고 부르자)&lt;/p&gt;

&lt;p&gt;우선순위 큐에서 최단 경로의 정점을 하나씩 꺼내면서 해당 정점과 연결된 정점들을 우선순위 큐에 넣는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;만약 v 에 아직 방문하지 않았고, 간선 (u, v) 를 검사한다고 하면 u 까지의 최단 거리에 간선 (u, v) 의 가중치를 더해서 v 까지의 거리를 구한다.&lt;/p&gt;

&lt;p&gt;만약 이 거리가 최단 거리라면 dist[v] 를 갱신하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(dist[v], v)&lt;/code&gt; 를 우선순위 큐에 다시 넣는다.&lt;/p&gt;

&lt;p&gt;여기서 주의해야할 것은 최단거리는 언제든지 갱신될 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;간선 (u, v) 를 탐색하면서 (dist[v], v) 를 우선순위 큐에 넣었는데 다른 정점을 돌면서 더 짧은 (dist[v], v) 를 우선순위 큐에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 우선순위 큐에 (dist[v], v) 가 여러 개 생길 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- 8 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 그래프에서 시작점이 A 라고 하자.  시작점을 탐색하면서 (20, D) 가 우선순위 큐에 들어가게 될 것이다.&lt;/p&gt;

&lt;p&gt;그러나 A, B, E 를 탐색하면서 (10 + 2 + 5, D) 도 우선 순위 큐에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;이 경우에 (20, D) 는 우선순위 큐에서 pop 된다고 해도 무시되어야 한다.&lt;/p&gt;

&lt;p&gt;(20, D) 가 pop 되었다는 것은 이미 이전에 (17, D) 가 pop 되었다는 것이고 dist[D] 는 17 일 것이다.&lt;/p&gt;

&lt;p&gt;따라서 dist[D] 와의 비교를 통해서 더 짧은 경로가 이전에 이미 탐색되었는지를 확인하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;증명&quot;&gt;증명&lt;/h2&gt;

&lt;p&gt;다익스트라의 증명은 귀류법(어떤 명제가 참이라고 가정한 후, 모순을 이끌어내 그 가정이 거짓임을, 즉 처음의 명제가 거짓임을 증명하는 방법) 을 통해 가능하다.&lt;/p&gt;

&lt;p&gt;여기서는 다익스트라를 통해 최단거리를 구할 수 없다고 가정하고 모순을 이끌어내려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- ? ---- B
   |             |
   ?             ?
   |             |
   D ---- ? ---- E -- ? -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 위의 그래프를 활용해서 이야기해보자.&lt;/p&gt;

&lt;p&gt;시작점 A 부터 E 까지의 거리를 구하는 것이 목표이고, 실제로는 A - D - E 가 가장 짧다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 다익스트라 알고리즘이 최단 거리를 제대로 구하지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;못한다&lt;/code&gt;고 가정하기 위해, 다익스트라 알고리즘이 A - B - E 가 가장 짧은 최단경로라는 결론을 내렸다고 가정해보자.&lt;/p&gt;

&lt;p&gt;도착점 E 에 도착한 순간, 어떤 정점은 이미 방문을 했을거고 또 어떤 정점은 우선순위 큐에 들어가 있는 상태일 수 있다.&lt;/p&gt;

&lt;p&gt;만약 D 를 방문하지 않은 상태라고 가정해보면, D 까지의 최단 거리는 dist[A] + w(A, D) 가 된다. 그런데 이미 방문한 정점 A 를 탐색하면서 D는 무조건 우선순위 큐에 (D, dist[A] + w(A, D)) 로 들어가게 되었을 것이다.&lt;/p&gt;

&lt;p&gt;A - B - E 로 진행하면서 E 또한 우선순위 큐에 들어가게 될텐데 여기서 이미 들어가있던 D 가 아닌 E 가 pop 되었다는것은 dist[E] 가 dist[D] 보다 작았기 때문이다.&lt;/p&gt;

&lt;p&gt;즉 dist[D] ≥ dist[E] 라는 소린데, 이는 D 를 거쳐서 A 에서 E 로 가는 것이 가장 짧은 경로라면 성립할 수가 없다.&lt;/p&gt;

&lt;h2 id=&quot;음수-가중치를-계산할-수-있는가&quot;&gt;음수 가중치를 계산할 수 있는가?&lt;/h2&gt;

&lt;p&gt;일반적으로 다익스트라 알고리즘은 음수 가중치가 있다면 정확한 최단 거리를 계산하지 못한다.&lt;/p&gt;

&lt;p&gt;음수 가중치가 있다는것은 이미 최단거리로 처리된 노드가 나중에 더 최단거리로 갱신될 가능성이 있다는 것이기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- -100 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다익스트라를 돌면서 E 의 최단 거리는 (10 + 2) 가 되겠지만 실제로는 10 + 2 - 100 이다.&lt;/p&gt;

&lt;p&gt;다시 말해서 이미 처리된 정점이 최단 거리라는 가정을 깨뜨릴 수 있다.&lt;/p&gt;

&lt;p&gt;만약 이미 처리된 정점이 최단 거리라는 가정을 버리고 (방문한 정점에 대한 기록을 하지 않고) 다익스트라를 작성한다면 음수 가중치를 계산할 수도 있다. 하지만, 이 경우에는 시간 복잡도가 정점의 갯수에 대해 지수함수로 증가할 수 있기 때문에 굳이 이런 식으로 다익스트라 알고리즘을 쓸 이유가 없다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;다익스트라의 시간 복잡도는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 정점마다 인접한 간선들은 모두 검사&lt;/code&gt; 하는 작업과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/code&gt; 하는 작업으로 나눌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;각-정점마다-인접한-간선들을-모두-검사&quot;&gt;각 정점마다 인접한 간선들을 모두 검사&lt;/h3&gt;

&lt;p&gt;정점의 갯수를 E, 간선의 갯수를 V 라고 할 때,&lt;/p&gt;

&lt;p&gt;각 정점마다 인접한 간선들을 모두 검사하는 작업은 정확히 모든 간선을 1번씩 검사하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(|E|)&lt;/code&gt; 의 시간이 걸리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;우선순위-큐에-원소를-넣고-삭제&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/h3&gt;

&lt;p&gt;우선순위 큐에 원소를 넣고 삭제하는 작업에서 최악의 경우에는 그래프의 모든 간선이 검사될 때마다 dist 배열이 갱신되면서 동시에 우선순위 큐에 정점의 번호가 추가되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/0.png&quot; alt=&quot;0&quot; /&gt;_다익스트라 최악의 경우 _&lt;/p&gt;

&lt;p&gt;위의 그래프에서 왼쪽의 핑크색 1번이 시작점이라고 하자.&lt;/p&gt;

&lt;p&gt;1번에서 2, 3, 4 까지의 dist 배열은 각각 6, 10, 15로 갱신되면서 우선순위 큐에 (2, 6), (10, 3), (15, 4) 로 들어갈 것이다.&lt;/p&gt;

&lt;p&gt;그러고 나서 2번 정점을 탐색하면서 dist[3] 은 6 + 3 으로 갱신되고, 우선순위 큐에 (9, 3) 이 추가 된다.&lt;/p&gt;

&lt;p&gt;이제 3번 정점을 탐색하면서 dist[4] 도 10 + 3 으로 갱신되고, 우선순위 큐에 (13, 4) 로 갱신 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;이처럼 최악의 시나리오에서는 각 간선마다 한 번씩 추가가 되고, 우선순위 큐에 원소를 추가하거나 삭제하는데 O(log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)의 시간이 걸리고 이를 O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) 개의 원소에 대해 작업을 해야하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(|E|log|E|)&lt;/code&gt; 가 된다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;일반적인-시간-복잡도&quot;&gt;일반적인 시간 복잡도&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;위의 두 과정을 더하게 되면 O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) = O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) 가 되는데, 보통 그래프에서 간선의 개수 E 는 V^2 보다 작기 때문에 O(log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) = O(log&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;) 라고 볼 수 있다. 따라서 O(ElogV) 라고 할 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;경로-추적&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘을 통해 최단 거리뿐만 아니라 최단 경로를 구하려면 정점에 도착하기 직전의 정점을 기록해서 역추적을 하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;벨만-포드&quot;&gt;벨만 포드&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘과 똑같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일&lt;/code&gt; 시작점 최단 경로 알고리즘이지만, 음수 가중치가 있는 그래프에서도 최단 경로를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 음수 사이클이 있어서 최단 거리를 제대로 구하지 못하는 경우도 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;벨만포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;알고리즘-동작&quot;&gt;알고리즘 동작&lt;/h2&gt;

&lt;p&gt;시작점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, 도착점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; , dist[k] = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점부터 k 까지의 최단 거리&lt;/code&gt; , w(u, v) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;= u와 v 사이의 간선 가중치&lt;/code&gt; 라고 하자. upper[k] 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재까지 계산된&lt;/code&gt;시작점부터 k 까지의 최단 거리이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 맨 처음에는 시작점부터 시작점사이의 거리가 0이라는 것을 제외하면, 아무것도 알고 있는 것이 없다. 따라서 upper[s] = 0 으로 초기화하고 나머지는 양의 무한대 혹은 매우 큰 수로 초기화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;완화&quot;&gt;완화&lt;/h3&gt;

&lt;p&gt;이제부터 우리는 upper 배열의 값을 점차 실제 최단 거리에 가깝도록 줄여나갈 것이다. 그러려면 최단 거리의 특성을 이용해야 하는데, 아래의 특성을 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dist[v] ≤ dist[u] + w(u, v)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;dist[v] 는 v 까지 최단 거리인데, 만약 u를 거쳐서 v 로 오는 거리가 더 짧다면, u를 거쳐오는 거리가 최단 거리여야한다. 그렇기때문에 dist[v] 가 최단 거리라는 가정에 위배된다.&lt;/p&gt;

&lt;p&gt;이번에는 upper[u] + w(u, v) &amp;lt; upper[v] 인 상황을 생각해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;upper[v] 를 upper[u] + w(u, v) 로 줄이려고 하는 것이 이번 과정의 목표이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;u 까지의 최단 거리는 항상 upper[u] 보다 작거나 같을 것이다.&lt;/p&gt;

&lt;p&gt;여기서 upper[u] + w(u, v) 는 u를 거쳐 v 로 가는 경로 이므로 만약 upper[u] + w(u, v) 가 upper[v] 보다 작다는 것은, u를 거쳐서 v 로 가는 것이 현재까지 계산된 v로 가는 최단 거리보다 짧다는 것이다.&lt;/p&gt;

&lt;p&gt;즉 upper[v] 를 upper[u] + w(u, v) 로 갱신할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완화&lt;/code&gt; 라고 하고 이를 계속 수행하면서 최단거리가 되도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;완화를-얼마나-해야하는가&quot;&gt;완화를 얼마나 해야하는가?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;최단거리는 결국, 어느 한 지점까지의 최단거리에서 간선을 더한 값으로 완화되어야 한다.&lt;/p&gt;

&lt;p&gt;무슨 이야기냐 하면 시작점 s 에서 연결된 정점 a 가 있다고 하자.&lt;/p&gt;

&lt;p&gt;모든 간선을 순회하면서 한 번씩 완화를 시도했다고 하자.&lt;/p&gt;

&lt;p&gt;이때 upper[a] 는 upper[s] + w(s, a) 로 완화될 수 있다. 그런데 upper[s] 는 시작점 s 부터 s 까지의 거리이므로 당연히 0이 된다.&lt;/p&gt;

&lt;p&gt;즉, upper[a] 는 w(s, a) 로 완화될 수 있다. w(s, a) 로 완화하고 나면, 시작점 s 부터 a 까지의 가는 경로중에 w(s, a) 보다 짧은 거리가 있을 수 있을까?&lt;/p&gt;

&lt;p&gt;없다. 위의 그래프에서 s 에서 b 로 가는 최단 거리가 s → b 말고 더 있을 수는 없다.&lt;/p&gt;

&lt;p&gt;여기서 만약 s → b → c → b 가 더 짧을 수도 있지 않을까 라는 생각이 들었다면 이는 음수 사이클이다. 이 경우에는 s→ b → c → b 보다 s → b → c → b → c → b 가 더 짧고 이를 무한반복하면 당연히 더 짧아진다.&lt;/p&gt;

&lt;p&gt;음수 사이클은 기본적으로 존재하는 순간 모든 그래프에서 최단 경로라는 말을 사용할 수가 없다.&lt;/p&gt;

&lt;p&gt;이는 조금 뒤에서 더 자세히 살펴보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 전체 간선에 대한 완화를 몇 번이나 수행해야 하는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그래프를 보면 전체 간선에 대한 완화를 1회 수행하면, a와 b 까지의 최단 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;2번 수행하면 c, 3번 수행하면 d 까지의 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 s → a → b → c → d 의 모양을 가진 그래프라면 어떨까?&lt;/p&gt;

&lt;p&gt;총 4회에 거쳐 a, b, c, d 까지의 최단 거리가 완화될 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서 정점의 갯수가 V 개 일때, 아무리 많이 해도 V - 1 번이면 모든 정점들까지의 거리가 최단 거리로 완화된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;음수-사이클&quot;&gt;음수 사이클&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프를 한 번 살펴보자. A → B → C 경로를 살펴보면 A → B 는 1 이 필요한데 B → C → A 는 가중치의 합이 -3 이다. A → B → C → A 는 결국 -2 의 가중치를 갖는다.&lt;/p&gt;

&lt;p&gt;어떠한 사이클이 합이 음의 가중치를 가지는 순간, 이 사이클을 무한 반복 함으로써 가중치의 합도 음의 무한대를 가지게 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서, 정점의 개수를 V 라고 할 때, 완화가 V - 1 번 이후에도 계속 이루어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 보면 음수 사이클을 판별하는 방법은 쉽다.&lt;/p&gt;

&lt;p&gt;V - 1 번까지 완화를 진행하고 V 번째 완화를 시도해보면 된다. 만약 완화가 이루어졌다면 음수 사이클이 존재하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적-1&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;벨만 포드의 경로 추적은 다익스트라의 경로 추적과 유사하다. 다익스트라처럼 역추적을 하면 되는데,&lt;/p&gt;

&lt;p&gt;각 정점을 마지막으로 완화시킨 간선들을 토대로 역추적하면 된다. (이 간선들은 항상 최단경로의 위에 있기 때문)&lt;/p&gt;

&lt;h2 id=&quot;경로-존재-유무-판별하기&quot;&gt;경로 존재 유무 판별하기&lt;/h2&gt;

&lt;p&gt;시작점 s 에서 u 까지의 경로가 있는지 판별하는 방법은 쉽게 생각하면 upper[u] 가 Infinity 가 아니면 경로가 있다라고 착각할 수 있다.&lt;/p&gt;

&lt;p&gt;경로가 있으면 무조건 완화가 이루어질 것이라고 생각할 수 있기 때문이다. 하지만 음수 사이클이 있다면 이야기가 조금 달라진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위처럼 시작점 s 가 다른 정점들과 간선이 없다고 해도, a ↔ b 사이의 음수 사이클을 통한 완화가 이루어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 경로의 존재 유무를 판별하려면 upper[u] 가 Infinity 인지 아닌지로 판별하는 것이 아닌, 적당히 큰 값 M 에 대해서 upper[u] &amp;lt; Infinity - M 인지를 확인해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;적당히-큰-값-m&quot;&gt;적당히 큰 값 M..?&lt;/h3&gt;

&lt;p&gt;M 은 그러면 어떻게 결정할 수 있을까?&lt;/p&gt;

&lt;p&gt;우리는 위에서 완화를 최대 V - 1 번 진행한다고 했다. 그렇기 때문에 음수 사이클을 돌면서 완화된다고 했을 때, 한 번의 완화에 가장 많이 완화되는 값은 가장 작은 가중치값의 2배를 넘지 않을 것이다.&lt;/p&gt;

&lt;p&gt;위의 그래프에서는 한 번의 완화당 -1 씩 (-2 + 1) 작아진다.&lt;/p&gt;

&lt;p&gt;따라서 (가장 작은 가중치 * 2) * (V - 1) 로 M 을 설정하면 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도-1&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;벨만 포드 알고리즘은 모든 간선을 순회하는 작업을 정점의 갯수 - 1 번 만큼 진행한다. 음수 사이클을 판별하려면정점의 갯수만큼 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 O(E * V) 가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정점의 갯수 : V, 간선의 갯수 : E&lt;/p&gt;

&lt;h1 id=&quot;플로이드&quot;&gt;플로이드&lt;/h1&gt;

&lt;p&gt;다익스트라와 벨만 포드 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 시작점에서 다른 모든 정점까지의 거리&lt;/code&gt; 를 구하는 알고리즘이었다. 플로이드는 한 시작점이 아닌, 모든 정점에서 모든 정점까지의 거리를 구할 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;사실 플로이드를 굳이 안쓰고 모든 정점에서 한 번씩 다익스트라 알고리즘을 수행해도 구할 수 있다. 음수 가중치가 있다면 모든 정점에서 벨만 포드 알고리즘을 쓸 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방법보다는 더 빠르게 수행할 수 있는 알고리즘이 플로이드 와샬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;플로이드 알고리즘은 생각보다 간단하다.&lt;/p&gt;

&lt;p&gt;정점 u 에서 v 까지의 거리를 dist[u][v] 라고 정했을 때 3중 for 문을 돌면서 u → ? → v 로 갔을 때, 거리가 갱신되는지 살펴보는 것이다.&lt;/p&gt;

&lt;p&gt;그런데 플로이드 알고리즘의 프로토타입을 글로 읽고 이해하려니 꽤나 많은 생각을 거쳐야 했다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입&quot;&gt;프로토타입&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

\[D_{[c, d]}(a, b) = 4\]

&lt;ul&gt;
  &lt;li&gt;위의 표현식은 a 에서 출발하여 c, d 를 거쳐 b 로 가는 경로이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그래프에서 정점들의 집합을 S 라고 하고, 임의의 점을 x 라고 하자.&lt;/p&gt;

&lt;p&gt;a 에서 f 로 가는 경로에서 x 를 경유하는 것과, 경유하지 않은 것을 나누어 나타내면&lt;/p&gt;

\[D_S(a, f) = \min \left\{
\begin{aligned}
    &amp;amp; D_{S - \{x\}}(a, x) + D_{S - \{x\}}(x, f), \\
    &amp;amp; D_{S - \{x\}}(a, f)
\end{aligned}
\right\}, \, x \in S\]

&lt;p&gt;기호가 너무 많아서 햇갈릴 수 있는데 a → f 의 경로는 x 를 경유해서 가는 것과 경유해서 가지 않는 것의 최소값이라는 의미일 뿐이다.&lt;/p&gt;

&lt;p&gt;여기서 이 점화식을 살짝 수정해서 더 보기 좋게 만들어보자.&lt;/p&gt;

\[S_{k} = {0, 1, 2, ..., k}\]

\[C_{k} = D_{S_{K}}\]

&lt;p&gt;이렇게 두 가지의 식을 활용해서 위의 식을 바꾸면&lt;/p&gt;

\[C_k(a, f) = \min \left\{
\begin{aligned}
    &amp;amp; C_{k-1}(a, k) + C_{k-1}(k, f), \\
    &amp;amp; C_{k-1}(a, f)
\end{aligned}
\right.\]

&lt;p&gt;이 된다.&lt;/p&gt;

&lt;p&gt;이제서야 우리가 자주 보던 점화식같이 생겼다.&lt;/p&gt;

&lt;p&gt;여기서&lt;/p&gt;

\[C_{k-1}(a, k) , C_{k}(a,k)\]

&lt;p&gt;이렇게 두 식의 차이점에 대해서 한 번 생각해보자.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이분 탐색</title>
      <link href="https://hoex5h.github.io/%EC%9D%B4%EB%B6%84_%ED%83%90%EC%83%89" rel="alternate" type="text/html" title="이분 탐색" />
      <published>2025-01-14T02:11:00+00:00</published>
      <updated>2025-01-14T02:11:00+00:00</updated>
      <id>https://hoex5h.github.io/%EC%9D%B4%EB%B6%84_%ED%83%90%EC%83%89</id>
      <content type="html" xml:base="https://hoex5h.github.io/%EC%9D%B4%EB%B6%84_%ED%83%90%EC%83%89">&lt;h1 id=&quot;이분-탐색&quot;&gt;이분 탐색&lt;/h1&gt;

&lt;p&gt;알고리즘 문제에서 단골 문제로 등장하는 이분 탐색을 정리하려고 한다.&lt;/p&gt;

&lt;p&gt;단순히 Target 을 찾는 것부터, Target 이 들어갈 자리(lower bound, upper bound)를 찾는 방법에 대해서도 한 번 정리해보자.&lt;/p&gt;

&lt;h2 id=&quot;이분-탐색target과-동일한게-있을-때&quot;&gt;이분 탐색(Target과 동일한게 있을 때)&lt;/h2&gt;

&lt;p&gt;이분 탐색의 가장 기초적인 형태로, 찾고 싶은 Target 이 몇 번째 인덱스에 존재하는지 찾는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
def simple_binary_search(target: int, arr: list):
    # 오름차순이라고 가정, 만약 arr 의 정렬이 보장되어 있지 않다면 정렬을 해야한다.
    arr.sort()

    start = 0
    end = len(arr) - 1

    while start &amp;lt;= end:
        mid = (start + end) // 2
        print(mid, arr[mid])

        if target &amp;gt; arr[mid]:
            start = mid + 1
        elif target &amp;lt; arr[mid]:
            end = mid - 1
        else:
            # target == arr[mid]
            return mid

    # target 을 찾지 못함
    return -



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이분 탐색은 말 그대로, 이등분하여 탐색하는 알고리즘이다. 로직을 자세히 보아도 이해하는데 크게 어려움은 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 target 이상인 것 중에 가장 첫 번째 인덱스를 찾고 싶거나, target 보다 큰 것중에 가장 작은 인덱스를 찾는 방법을 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;lower-bound&quot;&gt;Lower Bound&lt;/h2&gt;

&lt;p&gt;(target &amp;lt;= arr[idx]) target 보다 크거나 같은 것 중에 가장 첫 번째 인덱스를 찾고 싶다면 어떻게 해야할까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
arr = [1, 3, 5, 5, 5, 7, 9]
target = 5

# 원하는 정답 = 2 (5, 5, 5의 인덱스 중에서 가장 작은 인덱스)
# 위의 simple_binary_search() 함수의 결과값 = 3

def lower_bound_bisect(target: int, arr: list):
    # 오름차순이라고 가정, 만약 arr 의 정렬이 보장되어 있지 않다면 정렬을 해야한다.
    arr.sort()

    start = 0
    end = len(arr)

    while start &amp;lt; end:
        mid = (start + end) // 2
        print(mid, arr[mid])

        if target &amp;gt;= arr[mid]:
            end = mid
        elif target &amp;lt; arr[mid]:
            start = mid + 1

        &quot;&quot;&quot;
        만약 target 보다 작다면, start 를 mid + 1 로 바꿔서 이분한 배열의 오른쪽만 다시 확인하게 하고
        만약 target 보다 크거나 같다면, mid 를 포함한 채로, 배열의 왼쪽을 다시 살펴본다.

        왜 mid - 1 이 아니라, mid 일까? -&amp;gt; 찾고 싶은 것이 `target 보다 크거나 같은 것` 이므로, target &amp;gt;= arr[mid] 를 만족하는 순간
        우리가 찾고자 하는 것이다. 그렇기 때문에 정답 범주에 넣어두어야 한다.
        &quot;&quot;&quot;
    return start



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;upper-bound&quot;&gt;Upper Bound&lt;/h2&gt;

&lt;p&gt;이번에는 target 보다 큰 것 중에, 가장 작은 인덱스 값을 알아보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
arr = [1, 3, 5, 5, 5, 7, 9]
target = 5

# 원하는 정답 = 5 (1, 3, 5, 5, 5까지는 target 보다 작거나 같은 값이고, 7부터 target 보다 큰 값이므로)

def upper_bound_bisect(target: int, arr: list):
    # 오름차순이라고 가정, 만약 arr 의 정렬이 보장되어 있지 않다면 정렬을 해야한다.
    arr.sort()

    start = 0
    end = len(arr)

    while start &amp;lt; end:
        mid = (start + end) // 2
        print(mid, arr[mid])

        if target &amp;gt; arr[mid]:
            end = mid
        elif target &amp;lt;= arr[mid]:
            start = mid + 1
        &quot;&quot;&quot;
        만약 target 보다 작거나 같다면, start 를 mid + 1 로 바꿔서 이분한 배열의 오른쪽만 다시 살펴보게 하고
        만약 target 보다 크다면, mid 를 포함한 채로 왼쪽을 다시 살펴보게 한다.

        왜 mid - 1 이 아니라, mid 일까? -&amp;gt; 찾고 싶은 것이 `target 보다 큰 것` 이므로, target &amp;gt; arr[mid] 를 만족하는 순간
        우리가 찾고자 하는 것이다. 그렇기 때문에 정답 범주에 넣어두어야 한다.
        &quot;&quot;&quot;
    return start


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;차이점&quot;&gt;차이점&lt;/h2&gt;

&lt;p&gt;단순 이분 탐색과 lower / upper bound 의 while 종료 조건 차이점을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while start &amp;lt;= end&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while start &amp;lt; end&lt;/code&gt; 이 있는데, Lower/Upper 탐색은 1캰씩 움직이며 찾아나가는데 start &amp;lt;= end 로 하게 되면 소수점 버림으로 인해서 무한 루프에 빠질 수 있다.&lt;/p&gt;

&lt;p&gt;또한 Lower/Upper 의 return 은 mid 가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 인데, 이는 당연하게도 Lower 과 Upper 이 각각 크거나 같은 것 중에 최소값, 큰 것 중에 최소값을 return 해야하기 때문이다.&lt;/p&gt;

&lt;p&gt;Lower/Upper 의 end 초기값도 조금 다른데, len(arr) - 1 이 아니라, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(arr)&lt;/code&gt; 이다. 이는 조건을 만족하는 곳이 없으면 무조건 len(arr) 의 위치에 넣으면 되기 때문이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">이분 탐색</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">우선순위 큐</title>
      <link href="https://hoex5h.github.io/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%ED%81%90" rel="alternate" type="text/html" title="우선순위 큐" />
      <published>2025-01-14T02:11:00+00:00</published>
      <updated>2025-01-14T02:11:00+00:00</updated>
      <id>https://hoex5h.github.io/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%ED%81%90</id>
      <content type="html" xml:base="https://hoex5h.github.io/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%ED%81%90">&lt;p&gt;이번에 네이버 부스트 캠프 베이직 과정을 진행하면서 자바스크립트를 쓰게 되었는데, 평소에는 파이썬을 자주 사용했었기 때문에 자바스크립트로 파이썬을 대체해보려고 노력했다.&lt;/p&gt;

&lt;p&gt;다만 파이썬에는 여러가지 자료구조와 함수들이 잘 구현되어 있는데 자바스크립트를 써보니까 우선순위 큐가 내장 라이브러리에 없었다!&lt;/p&gt;

&lt;p&gt;이번 기회에 자바스크립트 공부 겸 힙과 우선순위 큐에 대해 다시 복습하고 직접 구현해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;heap&quot;&gt;Heap&lt;/h1&gt;

&lt;p&gt;우선 순위 큐는 힙 자료구조를 사용하기 때문에 힙이 무엇인지 알고 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;힙(Heap)&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최댓값 혹은 최솟값을 빠르게 찾아내는 연산을 위해&lt;/code&gt; 설계된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완전 이진 트리&lt;/code&gt; 자료구조이다.&lt;/p&gt;

&lt;p&gt;최댓값을 빠르게 찾고 부모노드의 키 값이 자식 노드의 키 값보다 항상 큰 힙을 최대 힙, 최솟값을 빠르게 찾고 부모노드의 키 값이 자식 노드의 키 값보다 항상 작은 힙을 최소 힙이라고 부른다.&lt;/p&gt;

&lt;p&gt;우선 순위 큐에서도 작을 수록 우선순위가 높은지, 클 수록 우선순위가 높은지에 따라 최대 힙, 최소 힙을 적절히 사용해야 한다.&lt;/p&gt;

&lt;p&gt;보통 최소 힙 라이브러리가 내장되어 있기 때문에, 만약 클 수록 우선순위가 높다면 데이터 전체에 -1 을 곱하는 등의 처리를 통해 최소 힙을 최대 힙처럼 사용할 수도 있다.&lt;/p&gt;

&lt;h1 id=&quot;우선-순위-큐&quot;&gt;우선 순위 큐&lt;/h1&gt;

&lt;p&gt;그렇다면 우선 순위 큐는 어떤 식으로 구현되어 있을까?&lt;/p&gt;

&lt;p&gt;최소 힙과 최대 힙은 거의 유사하기도 하고, 위에서 말한 것처럼 활용할 수도 있기 때문에 최소 힙 우선순위 큐를 한 번 살펴보려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class PriorityQueue {
  constructor() {
    this.heap = []; // 데이터를 담을 배열
  }

  enqueue(value) {
    // 1. 힙 자료구조에 value 를 넣고
    // 2. value 가 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; 아래의 bubbleUp 함수를 사용할 예정
  }

  dequeue() {
    // 1. 힙 자료구조의 루트 노드에 해당하는 값을 임시로 저장해두고
    // (pop 이 아님! pop(0)은 O(n) 의 시간복잡도를 가지기 떄문에 힙 자료구조를 사용하는 의미가 없어짐
    // 2. 맨 마지막 리프 노드에 해당하는 값을 루트 노드에 저장하고,
    // 3. 해당 루트 노드의 값이 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; 아래의 bubbleDown 함수를 사용할 예정
  }

  peek() {
    // 루트 노드를 pop 하는 것이 목적이 아닌, 그저 루트 노드를 참조하고자 할 때
    return this.heap.length &amp;gt; 0 ? this.heap[0] : null;
  }

  bubbleUp(index) {
    // index 번 째에 해당하는 노드의 값보다 작은 값이 있다면, index 노드를 위로 올려보내야 한다.
  }

  bubbleDown(index) {
    // index 번 째에 해당하는 노드의 값보다 큰 값이 있다면, index 노드를 아래로 내려보내야 한다.
  }

  swap(i, j) {
    // i, j 값 스왑
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수를 구현하기 전에 간략한 설명과 함께 하나씩 구현해보자.&lt;/p&gt;

&lt;h2 id=&quot;bubbleup&quot;&gt;bubbleUp&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
bubbleUp(index) {
  // index 번 째에 해당하는 노드의 값보다 작은 값이 있다면, index 노드를 위로 올려보내야 한다.
    while (index &amp;gt; 0) {
    const parentIndex = Math.floor((index - 1) / 2); // index 노드의 부모 노드 구하기.
    if (this.heap[parentIndex] &amp;lt;= this.heap[index]) break; // 최소 힙이므로 부모노드는 항상 자식 노드보다 작거나 같다!

    this.swap(index, parentIndex); // index 랑 부모노드랑 스왑
    index = parentIndex; // 부모노드로 올라간 index 부터 반복
  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자식노드(index) 와 부모노드를 비교하는 bubbleUp 함수.&lt;/p&gt;

&lt;p&gt;bubbleUp 함수는 우리가 버블정렬을 하는 것 처럼, 두 값을 비교해서 위치를 바꾸는 함수이다.
최소 힙을 구현하려고 하므로 부모노드는 항상 자식 노드보다 작거나 같아야 한다.&lt;/p&gt;

&lt;p&gt;부모노드의 값을 구하는 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Math.floor((index - 1) / 2)&lt;/code&gt; 인데&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부모노드(0) -&amp;gt; 자식 노드(1, 2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;부모노드(1) -&amp;gt; 자식 노드(3, 4)


부모노드(n) -&amp;gt; 자식 노드(2n + 1, 2n + 2) 임을 알 수 있다.


따라서 자식 노드가 +1, +2(왼쪽, 오른쪽) 중에 어떤 쪽인지에 상관없이 부모노드를 구하는 방법이 위의 방법인 것이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bubbledown&quot;&gt;bubbleDown&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
  bubbleDown(index) {
    // index 번 째에 해당하는 노드의 값보다 큰 값이 있다면, index 노드를 아래로 내려보내야 한다.
    while (true) {
      const leftChildIndex = 2 * index + 1; // 왼쪽 자식 노드
      const rightChildIndex = 2 * index + 2; // 오른쪽 자식 노드
      let smallestIndex = index; // 부모노드, 왼쪽 자식노드, 오른쪽 자식 노드 중에 가장 작은 값을 저장할 변수

      if (leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.heap[leftChildIndex] &amp;lt; this.heap[smallestIndex]) {
        // 만약 부모노드보다 왼쪽 자식 노드가 작다면 smallestIndex 를 왼쪽 자식 노드로 변경
        smallestIndex = leftChildIndex;
      }

      if (rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.heap[rightChildIndex] &amp;lt; this.heap[smallestIndex]) {
        // 만약 위의 if 문에서 왼쪽 자식 노드가 작았다면 smallestIndex 는 왼쪽 자식 노드,
        // 아니라면 부모 노드
        // 똑같이 오른쪽 자식 노드랑 비교
        smallestIndex = rightChildIndex;
      }
      // 만약 가장 작은 노드가 부모 노드라면 최소 힙의 조건을 만족하므로 break
      if (smallestIndex === index) break;

      // 자식 노드 중에 더 작은 노드(smallestIndex) 와 부모노드를 스왑
      this.swap(index, smallestIndex);

      //더 작은 노드의 위치에 index 노드를 두고 반복
      index = smallestIndex;
    }
  }


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bubbleDown 도 bubbleUp 와는 반대로 내려오는 것이기 때문에,&lt;/p&gt;

&lt;p&gt;index에 해당하는 노드가 제자리를 찾을 때까지 자식 노드와의 비교를 반복한다.&lt;/p&gt;

&lt;h2 id=&quot;enqueue-dequeue&quot;&gt;enqueue, dequeue&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
  enqueue(value) {
    // 1. 힙 자료구조에 value 를 넣고
    this.heap.push(value);
    // 2. value 가 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; 아래의 bubbleUp 함수를 사용할 예정
    this.bubbleUp(this.heap.length - 1);
  }

  dequeue() {
    if (this.heap.length === 0) return null;

    // 1. 힙 자료구조의 루트 노드(0번째 Index)에 해당하는 값을 임시로 저장해두고
    // (pop 이 아님! pop(0)은 O(n) 의 시간복잡도를 가지기 떄문에 힙 자료구조를 사용하는 의미가 없어짐
    const min = this.heap[0];
    // 2. 맨 마지막 리프 노드에 해당하는 값을 루트 노드에 저장하고,
    const last = this.heap.pop();
    if (this.heap.length &amp;gt; 0) {
      this.heap[0] = last;

      // 3. 해당 루트 노드의 값이 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; bubbleDown
      this.bubbleDown(0);
    }

    return min;
  }


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">이번에 네이버 부스트 캠프 베이직 과정을 진행하면서 자바스크립트를 쓰게 되었는데, 평소에는 파이썬을 자주 사용했었기 때문에 자바스크립트로 파이썬을 대체해보려고 노력했다.</summary>
      

      
      
    </entry>
  
</feed>
