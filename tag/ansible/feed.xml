<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hoex5h.github.io/tag/ansible/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hoex5h.github.io/" rel="alternate" type="text/html" />
  <updated>2025-01-15T10:41:36+00:00</updated>
  <id>https://hoex5h.github.io/tag/ansible/feed.xml</id>

  
  
  

  
    <title type="html">hoeeeeeh | </title>
  

  
    <subtitle>HOEH 개발 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">[Kuploy Project] Kuploy History</title>
      <link href="https://hoex5h.github.io/Kuploy_Project-_Kuploy_History" rel="alternate" type="text/html" title="[Kuploy Project] Kuploy History" />
      <published>2025-01-14T02:40:00+00:00</published>
      <updated>2025-01-14T02:40:00+00:00</updated>
      <id>https://hoex5h.github.io/%5BKuploy_Project%5D_Kuploy_History</id>
      <content type="html" xml:base="https://hoex5h.github.io/Kuploy_Project-_Kuploy_History">&lt;h1 id=&quot;kuploy-kuploy-history&quot;&gt;[Kuploy] Kuploy History&lt;/h1&gt;

&lt;p&gt;CICD 자동화 프로젝트를 만들면서 수정사항이 정말 아주 많이 생기고 있는데,&lt;/p&gt;

&lt;p&gt;History 를 보기 좋게 작성해 두는 것이 추후 프로젝트를 리팩토링할 때 아주 쓸모 있을 것 같다.&lt;/p&gt;

&lt;p&gt;살짝 늦은 감이 없지 않지만,,&lt;/p&gt;

&lt;h2 id=&quot;kubernetes&quot;&gt;Kubernetes&lt;/h2&gt;

&lt;h3 id=&quot;kompose&quot;&gt;Kompose&lt;/h3&gt;

&lt;p&gt;Docker-compose 파일을 k8s 에 apply 시키기 위한 tool 이다.&lt;/p&gt;

&lt;p&gt;현재 버전은 1.31.0 사용 중이다.&lt;/p&gt;

&lt;h3 id=&quot;kompose-문제점&quot;&gt;Kompose 문제점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;-controller statefulset&lt;/p&gt;

    &lt;p&gt;statefulset 을 만들기 위해서 flag 를 썼더니 json 마지막 부분에 status: 항목이 생겨있다.&lt;/p&gt;

    &lt;p&gt;status 는 쿠버네티스가 배포/운영 하면서 쓰는 항목이지 apply 하기 전에 쓰는 항목이 아닐텐데 이게 왜 생기지?&lt;/p&gt;

    &lt;p&gt;심지어 status: replica : 0 으로 잡혀있어서, 만들자마자 replica 가 1이 되기 때문에 Live Manifest 와 Desired Manifest 가 달라져서 바로 out of sync 상태가 된다…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-namespace={“namespace”}
모든 항목의 네임스페이스를 지정해주려고 하니 namespace.yaml 파일을 만들어버린다.&lt;/p&gt;

    &lt;p&gt;이대로 배포하면 namespace.yaml 이 apply 되면서 배포한 어플리케이션의 일부가 되어버리는데,&lt;/p&gt;

    &lt;p&gt;어플리케이션을 삭제하면 namespace 도 삭제된다..&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;metrics-server&quot;&gt;Metrics Server&lt;/h3&gt;

&lt;p&gt;K8s 에 배포되어있는 리소스들의 메트릭을 관찰할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;cni-calico&quot;&gt;CNI (Calico)&lt;/h3&gt;

&lt;p&gt;K8s 의 노드들이 통신하는 규약&lt;/p&gt;

&lt;p&gt;여러가지 종류가 있지만 현재 Calico 사용 중&lt;/p&gt;

&lt;h3 id=&quot;storage-class&quot;&gt;Storage Class&lt;/h3&gt;

&lt;p&gt;Persisten Volume Claim 을 만들 때, Storage Class 를 사용하는데&lt;/p&gt;

&lt;p&gt;Storage Class 에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;provisioner&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parameters&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reclaimPolicy&lt;/code&gt; 를 정의할 수 있다.&lt;/p&gt;

&lt;p&gt;Storage Class 에 대한 자세한 설명은 &lt;a href=&quot;추후 작성 예정&quot;&gt;여기&lt;/a&gt;를 참고하면 된다.&lt;/p&gt;

&lt;p&gt;Kuploy는 로컬에 저장할 수 있으면서 동시에 동적 프로비저닝을 할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;이러한 조건을 만족시켜주는 Storage Class 가 &lt;a href=&quot;https://github.com/rancher/local-path-provisioner&quot;&gt;Rancher/local-path-provisioner&lt;/a&gt; 였다.&lt;/p&gt;

&lt;p&gt;현재는 다른 storage class를 사용할 필요가 없기 때문에 default storage class 이다. (따로 storage class 가 지정되지 않으면 자동으로 default storage class 로 지정)&lt;/p&gt;

&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;

&lt;h3 id=&quot;docker-hub&quot;&gt;Docker hub&lt;/h3&gt;

&lt;p&gt;유저들의 이미지를 저장할 레지스트리를 on-premise 로 만들 여력이,, 안되어서 도커 허브를 쓰기로 했다&lt;/p&gt;

&lt;p&gt;나중에 저장소가 많이 늘어난다면 사설 레지스트리를 써보거나, Harbor 혹은 Nexus 를 써볼 수도?&lt;/p&gt;

&lt;h2 id=&quot;github-action&quot;&gt;Github Action&lt;/h2&gt;

&lt;h2 id=&quot;argocd&quot;&gt;Argocd&lt;/h2&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;h3 id=&quot;argocd-api&quot;&gt;Argocd Api&lt;/h3&gt;

&lt;p&gt;Kuploy 웹에 사용자가 어떤 어플리케이션을 배포중인지 보여주기 위해서 사용했다.&lt;/p&gt;

&lt;h3 id=&quot;argocd-image-updater&quot;&gt;Argocd Image Updater&lt;/h3&gt;

&lt;p&gt;사용자들이 소스코드의 변경 -&amp;gt; image push 하는 과정만 존재할 경우,&lt;/p&gt;

&lt;p&gt;즉 현재 argocd 가 호시탐탐 지켜보고 있는 application 의 status 에 변화를 불러 일으킬만한 변경점이 없다면 sync 되지 않는다.&lt;/p&gt;

&lt;p&gt;우리는 image version 이 바뀌는 것도 sync 를 해야한다.&lt;/p&gt;

&lt;h3 id=&quot;trouble-shooting&quot;&gt;Trouble Shooting&lt;/h3&gt;

&lt;h3 id=&quot;절대-project-name-을-멋대로-짓지-마&quot;&gt;절대 Project Name 을 멋대로 짓지 마.&lt;/h3&gt;

&lt;p&gt;Project Name 을 IDE 에서 프로젝트 생성할 때 짓는 이름 쯤으로 생각하면 무한 오류에 빠진다.&lt;/p&gt;

&lt;p&gt;이거 때문에 교수님 앞에서 눈물의 에러쇼를 했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;당신이 원하는 프로젝트 네임을 적는 것이 아니라 ArgoCD에 미리 생성한 Project 중에 하나를 고르는 것이다!!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;기본으로 default 프로젝트가 존재하고, 따로 원하면 만들 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Kubernetes" />
      
        <category term="Ansible" />
      
        <category term="ArgoCD" />
      
        <category term="Docker" />
      
        <category term="Linux" />
      

      
        <summary type="html">[Kuploy] Kuploy History</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">[Kuploy Project] Kuploy</title>
      <link href="https://hoex5h.github.io/Kuploy_Project-_Kuploy_" rel="alternate" type="text/html" title="[Kuploy Project] Kuploy " />
      <published>2025-01-14T02:40:00+00:00</published>
      <updated>2025-01-14T02:40:00+00:00</updated>
      <id>https://hoex5h.github.io/%5BKuploy_Project%5D_Kuploy_</id>
      <content type="html" xml:base="https://hoex5h.github.io/Kuploy_Project-_Kuploy_">&lt;h1 id=&quot;kuploy-kuploy-는-어떤-프로젝트인가&quot;&gt;[Kuploy] Kuploy 는 어떤 프로젝트인가?&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kuploy 는 Konkuk + Deploy 의 합성어로 건국대학교 학생들의 Deploy 를 도와주기 위한 프로젝트이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;유휴-컴퓨팅-리소스를-활용해서-학생들에게-제공해주자&quot;&gt;유휴 컴퓨팅 리소스를 활용해서 학생들에게 제공해주자!&lt;/h2&gt;

&lt;p&gt;처음 시작은 건국대학교의 유휴 컴퓨팅 리소스들을 활용하여 학생들에게 제공해주자! 라는 취지를 가진 프로젝트였다. 이게 무슨말인가 하면,&lt;/p&gt;

&lt;p&gt;건국대학교에는 수 많은 컴퓨터들이 학생들의 수업, 실습을 위해 존재한다. 하지만 실제로 이 컴퓨터들은 수업 시간 외에는 잘 사용되지 않는다.&lt;/p&gt;

&lt;p&gt;실습용 컴퓨터도 마찬가지인데, 요새는 대부분 노트북을 하나씩 소유하고 있다보니 모여서 프로젝트를 하는 팀플의 경우를 제외하고는 잘 사용되지 않는다. 이런 상황이다보니 많은 컴퓨터들이 사용되지도 않은 채 관리 미흡으로 먼지가 쌓여가고 있었다.&lt;/p&gt;

&lt;p&gt;이렇게 잘 사용되지 않는, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유휴 컴퓨팅 리소스들을 잘 합쳐서 학생들에게 사용할 수 있게끔 제공&lt;/code&gt;한다면 학교와 학생 모두가 좋은 일이 아닐까? 라는 긍정적인 사고의 결과물이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kuploy&lt;/code&gt; 프로젝트이다.&lt;/p&gt;

&lt;h2 id=&quot;학교의-컴퓨터들-그냥-원격으로-쓰면-안돼&quot;&gt;학교의 컴퓨터들 그냥 원격으로 쓰면 안돼?&lt;/h2&gt;

&lt;p&gt;우리의 목적은 단순히 유휴 컴퓨터들 하나하나에 Teamviewer 를 깔아서 학생들에게 GUI 원격으로 사용할 수 있게 하거나, 아니면 그냥 ssh 를 열어서 사용할 수 있게끔 하는 것이 아니다. 만약 이런 것이 목적이였다면 프로젝트 이름은 Kuploy 가 아니라 Kumote(Kuploy + Remote) 가 되지 않았을까?&lt;/p&gt;

&lt;p&gt;우리는 학교의 유휴 컴퓨팅 리소스 뿐만 아니라 개발 프로세스 자동화에도 관심이 많이 있었다.&lt;/p&gt;

&lt;p&gt;학생들은 주로 AWS 를 이용해서 자신들의 프로젝트를 테스트하고 서비싱한다. 이렇게 서비싱하는 과정은 크게 아래의 3가지 절차를 밟는다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AWS Free tier(신규 회원은 1년간 공짜니까!) ec2 생성&lt;/li&gt;
  &lt;li&gt;Inbound, Outbound 규칙 생성(일단 ssh 부터 뚫어놔야 나도 접근할 수 있으니까)&lt;/li&gt;
  &lt;li&gt;프로젝트 build 파일들을 ec2 에 옮겨서 run 하거나, docker를 활용하여 run&lt;/li&gt;
  &lt;li&gt;변경사항이 생긴다면 github 에 commit push 후, 3번과정을 다시 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 과정은 복잡하지는 않지만 새로운 프로젝트를 할 떄마다 매번 해줘야하는 번거로움이 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;게다가 Free tier 는 성능이 썩 좋은 편은 아니다. 실제로 프로젝트를 진행하던 도중 ec2 의 메모리 부족으로 제대로 실행시킬 수 없는 경우도 있었다. 메모리 스왑을 통해 임시 방편을 마련해놨었지만 말 그대로 임시방편일 뿐이다.&lt;/p&gt;

&lt;p&gt;이러다보니 매번 할 때마다 귀찮은 반복 작업이 필요하며, 성능에도 제한이 있어서 제대로 활용하기 힘든 AWS 를 대체하고 싶었다.&lt;/p&gt;

&lt;p&gt;Kuploy 에서는 건국대학교 학생 한정으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Free tier 보다 높은 성능(물론, 상한선은 있다)을 제공하면서 동시에 배포 과정을 최적화&lt;/code&gt;시킬 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;kuploy-프로젝트의-진행-과정&quot;&gt;Kuploy 프로젝트의 진행 과정&lt;/h1&gt;

&lt;h2 id=&quot;cluster-구축&quot;&gt;Cluster 구축&lt;/h2&gt;

&lt;p&gt;우리는 우선 교수님으로부터 총 4대의 학교 컴퓨터를 대여 받았다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1대의 Master Node&lt;/li&gt;
  &lt;li&gt;2대의 Worker Node&lt;/li&gt;
  &lt;li&gt;1대의 Ansible Control Node&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4대의 컴퓨터들은 이렇게 구성해서 클러스터를 구축하기로 결정하였고, 그 전에 4대의 컴퓨터들을 초기화해서 셋팅할 것이 많이 있었다.&lt;/p&gt;

&lt;h3 id=&quot;master-node-worker-node-공통-설정&quot;&gt;Master Node, Worker Node 공통 설정&lt;/h3&gt;

&lt;h3 id=&quot;ubuntu-2204-server-lts-설치&quot;&gt;Ubuntu 22.04 Server LTS 설치&lt;/h3&gt;

&lt;p&gt;일단 &lt;a href=&quot;https://releases.ubuntu.com/jammy/&quot;&gt;Ubuntu 22.04&lt;/a&gt; 에서 설치할 OS 환경을 잘 골라서 Ubuntu 22.04 live server 의 iso 파일을 다운받자.&lt;/p&gt;

&lt;p&gt;이제 부팅 디스크로 USB를 만들어야하는데, 집에 USB가 다 어딘가로 사라지고 없어서 SanDisk 사의 USB 2개를 구매하였다.&lt;/p&gt;

&lt;p&gt;USB를 간단한 방법으로 설치 디스크로 만드는 툴은 크게 2개가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Rufus&lt;/li&gt;
  &lt;li&gt;Ventoy&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 중에 우리는 Ventoy 를 활용했다. 이유는 Rufus 보다 훨씬 쉽고 간단하다!
우선 &lt;a href=&quot;https://www.ventoy.net/en/download.html&quot;&gt;Ventoy&lt;/a&gt; 링크를 통해 본인의 OS에 맞는 Ventoy 툴을 다운받자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kuploy_Project]_Kuploy_.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이후에 Ventoy2Disk 를 실행하고 부팅 디스크로 만들 USB 를 선택한 후, Install 을 누르면 준비 끝이다.&lt;/p&gt;

&lt;p&gt;이후에 iso 파일을 USB에 넣어주기만 하면 자동으로 부팅디스크가 된다.&lt;/p&gt;

&lt;p&gt;이렇게 만든 부팅 디스크를 꽂고 설치하면 된다!
만약 위에서 만든 USB로 부팅되지 않는다면 BIOS 에서 부팅 순서를 바꿔보도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;스왑-메모리-끄기&quot;&gt;스왑 메모리 끄기&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
$ sudo swapoff -a

# 재부팅 후에 스왑 메모리가 자동으로 켜지는 것 방지
$ sudo vim /etc/fstab

# 스왑 파티션(아래 줄) 주석 처리
# /swap.img     none    swap    sw      0       0



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;쿠버네티스가 메모리를 할당할 때, 스왑메모리가 있으면 문제를 초래할 수 있다.
애초에 쿠버네티스가 리소스 관리를 하기 때문에 필요 하지도 않다. 스왑 메모리가 꺼졌는지 확인해보려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free&lt;/code&gt; 커맨드를 사용해보면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;swapoff -a 는 일시적으로 스왑 메모리를 끄는 것이다. 만약 /etc/fstab 에서 스왑 메모리를 영구적으로 끄지 않는다면 컴퓨터를 재부팅했을 때 자동으로 스왑 메모리가 켜지게 된다. 이 경우에 쿠버네티스가 정상적으로 작동하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;스왑 메모리가 켜진 상태로 kubectl get nodes 명령어를 입력해보면 Ready여야 하는 노드가 NotReady 상태로 변경되고, 해당 노드에서 실행중인 Pod 들은 Terminating 상태나 Pending 상태에 무한히 빠진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;방화벽ufw-포트-allow&quot;&gt;방화벽(ufw) 포트 allow&lt;/h3&gt;

&lt;p&gt;쿠버네티스 apiserver 가 6443 포트를 사용하기 때문에, 6443 포트를 뚫어주어야 api-server 와 통신할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
$ sudo ufw allow {port}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;kubectl-kubelet-kubeadm-docker-설치&quot;&gt;kubectl, kubelet, kubeadm, docker 설치&lt;/h3&gt;

&lt;p&gt;최신 버전을 사용하면서 충돌 날 것을 우려하여 1.23.6-00 버전으로 명시하여 설치하였다.&lt;/p&gt;

&lt;p&gt;설치 이전에 epel, net-tools 를 설치한다.&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;EPEL, net tools 는 뭘까?&lt;/summary&gt;
&lt;code&gt;
&lt;pre&gt;


`EPEL` == Extra Packages for Enterprise Linux
말 그대로 엔터프라이즈 리눅스를 위한 추가 패키지이다. 기본 레포에 없는 오픈 소스들을 사용할 수 있다.


`net-tools` 는 리눅스의 네트워킹 관련 커맨드라인 도구 모음이다.


&amp;gt; A collection of programs that form the base set of the NET-3 networking distribution for the Linux operating system.  
&amp;gt; Includes: arp, hostname, ifconfig, netstat, rarp, route, plipconfig, slattach, mii-tool and iptunnel and ipmaddr.  
&amp;gt; A mirror of the sourcecode is available on https://github.com/ecki/net-tools


&lt;/pre&gt;&lt;/code&gt;
&lt;/details&gt;

&lt;details&gt;
&lt;summary&gt; 쿠버네티스 1.24 미만 버전 &lt;/summary&gt;
&lt;code&gt;
&lt;pre&gt;



```
shell
# install Extra Packages for Enterpries Linux System, Docker
sudo apt-get install epel-release -y
sudo apt-get install net-tools -y
sudo apt-get update &amp;amp;&amp;amp; sudo apt-get -y upgrade

# Install Kubernetes Package
# Add Google Cloud Public GPG Key to apt
sudo curl -s &amp;lt;https://packages.cloud.google.com/apt/doc/apt-key.gpg&amp;gt; | sudo apt-key add -

# Create new APT source list
cat &amp;lt;&amp;lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb &amp;lt;https://apt.kubernetes.io/&amp;gt; kubernetes-xenial main
EOF

# Update APT Package and upgrade all package
# flag -y means all yes
sudo apt-get update &amp;amp;&amp;amp; sudo apt-get -y upgrade

# Install Kubernetes - kubectl, kubelet, kubeadm
sudo apt-get install -y kubelet=1.23.6-00 kubeadm=1.23.6-00 kubectl=1.23.6-00

# hold kubelet, kubeadm, kubectl version
sudo apt-mark hold kubelet kubeadm kubectl

echo &quot;sleep 3 sec&quot;
sleep 3

sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade

sudo systemctl daemon-reload
sudo systemctl restart kubelet

echo &quot;Installing Docker&quot;
sudo curl -sSL &amp;lt;https://get.docker.com/&amp;gt; | sh

echo &quot;sleep 1 sec&quot;
sleep 1

echo &quot;sleep 3 sec&quot;
sleep 3


```



&lt;/pre&gt;&lt;/code&gt;
&lt;/details&gt;

&lt;p&gt;쿠버네티스 버전을 1.24 이상 버전을 사용하면서, docker 에서 containerd 로 옮겨가게 되었다. 쿠버네티스와 containerd 의 설치 방법은 &lt;a href=&quot;https://hoex5h.github.io/kubernetes/2024/04/06/kubernetes_containerd.html&quot;&gt;k8s-docker-containerd&lt;/a&gt; 에 적어두었다.&lt;/p&gt;

&lt;h3 id=&quot;containerd-설정&quot;&gt;containerd 설정&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;systemd-를-cgroup-driver-로-설정하기&quot;&gt;systemd 를 cgroup driver 로 설정하기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/containerd/config.toml&lt;/code&gt; 에 아래 항목 추가&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  ...
  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
    SystemdCgroup = true


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
sudo systemctl restart containerd


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;containerd 재시작.&lt;/p&gt;

&lt;h3 id=&quot;ipv4-포워딩-bridge-iptable-규칙-수정&quot;&gt;IPv4 포워딩, bridge iptable 규칙 수정&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/container-runtimes/#containerd&quot;&gt;Container Runtime&lt;/a&gt; 쿠버네티스 공식 문서를 참조해서 진행했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
cat &amp;lt;&amp;lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# sysctl params required by setup, params persist across reboots
cat &amp;lt;&amp;lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

# Apply sysctl params without reboot
sudo sysctl --system


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 커맨드로 br_netfilter 와 overlay 모듈이 load 되어 있는지 확인해보라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
lsmod | grep br_netfilter
lsmod | grep overlay


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 sysctl에 저 3가지 항목의 값이 1로 설정되어 있는지 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cgroup&quot;&gt;cgroup&lt;/h3&gt;

&lt;p&gt;리눅스는 cgroup가 프로세스의 리소스를 제한하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;kubelet과 containerd 도 pod의 리소스를 제한하는데 cgroup driver 를 사용해야 하는데, 반드시 kubelet 과 containerd 는 같은 구성의, 같은 cgroup driver 를 사용해야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;cgroup driver 에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cgroupfs&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 가 존재하는데 만약 init 프로세스가 systemd 인 경우에는 kubelet 과 containerd 의 cgroup driver 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;systemd&lt;/code&gt; 를 사용하도록 권장하고 있다. 이유는 systemd 가 cgroup 관리자는 하나라고 인식하기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;추가로 cgroup v2 를 사용할 경우에도 systemd 를 사용하라고 한다. cgroup v2 가 무엇인지 문서를 읽어보니 cgroup 의 업그레이드 버젼인듯 하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;kubelet-의-cgroup-driver-를-systemd-로-수정하기&quot;&gt;kubelet 의 cgroup driver 를 systemd 로 수정하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/tasks/administer-cluster/kubelet-config-file/&quot;&gt;kubelet-config-file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;kubeadm 을 통해 init 을 하고 난 후에, kubelet 의 config 파일을 아래처럼 수정해주면 된다. 아직 kubeadm init 후에 적용하면 되기 때문에 지금 당장 config 파일을 만들 필요는 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kuploy_Project]_Kuploy_.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;master-node-설정&quot;&gt;Master Node 설정&lt;/h2&gt;

&lt;h3 id=&quot;kubeadm-init&quot;&gt;kubeadm init&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
$ sudo kubeadm init --apiserver-advertise-address=[마스터 노드 IP] --pod-network-cidr=[CNI 네트워크 라우팅 대역]


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마스터노드에서 kubeadm 을 init 하면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;네트워크 라우팅 대역&lt;/code&gt; 을 입력해야하는데, Calico 를 사용한다면 192.168.0.0/16 를 입력해 주면 된다.&lt;/p&gt;

&lt;p&gt;cidr 에 관해서는 &lt;a href=&quot;https://hoex5h.github.io/network/2024/03/22/cidr.html&quot;&gt;Gateway,사설망,CIDR&lt;/a&gt; 을 참조하자!&lt;/p&gt;

&lt;p&gt;해당 커맨드를 입력하면 아래와 같은 결과값이 반환되는데 이를 어딘가에 적어두거나 기억해두자. 추후 Worker Node 설정에 필요하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
# 딱히 건들지 않았다면 api-server 의 포트가 6443 으로 설정되어 있을 것이라서 마스터 노드의 6443 포트를 입력한다.
sudo kubeadm join {마스터 노드 IP}:6443 --token {토큰값~}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후에 config 에 권한을 부여해줘야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
sudo mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
systemctl restart kubelet
systemctl restart docker


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cnicontainer-network-interface&quot;&gt;CNI(Container Network Interface)&lt;/h3&gt;

&lt;p&gt;CNI에 대한 자세한 내용은 따로 작성해둔 &lt;a href=&quot;https://hoex5h.github.io/kubernetes/2024/03/21/kubernetes_cni.html&quot;&gt;Kubernetes-CNI&lt;/a&gt; 문서를 참조하자.&lt;/p&gt;

&lt;p&gt;우리는 CNI 로 calico 를 선택했다. 사실 이렇게 소규모 프로젝트에서 어떤 CNI를 쓰든 큰 차이가 나지는 않을 것이다. 가장 대중적으로 사용하는 Calico, Flannel, Weave Net 정도의 차이점만 알아보았는데 대규모 트래픽 연산(성능) 측면에서는 L3를 활용하는, 즉 모든 Container 마다 ip를 부여해서 통신하는 Calico의 성능이 제일 좋았고, 간편성만 따졌을 때는 Flannel 이 제일 좋았다. WeaveNet은 Mesh 네트워크 구조라서 성능이 나머지 두 플러그인에 비해 조금 떨어진다.&lt;/p&gt;

&lt;p&gt;대규모 트래픽 연산에 성능이 좋은 Calico와, 소규모 프로젝트에 어울리는 Flannel 중에서 선택을 고민했고 Calico 가 조금 더 대중적인 이유를 고려해서 Calico를 선택했다.&lt;/p&gt;

&lt;h3 id=&quot;calico-설치&quot;&gt;Calico 설치&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
# 2024-03-22 기준!
$ kubectl create -f &amp;lt;https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/tigera-operator.yaml&amp;gt;
$ kubectl create -f &amp;lt;https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/custom-resources.yaml&amp;gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;더 자세한 것은 &lt;a href=&quot;https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart&quot;&gt;Calico 공식 홈페이지&lt;/a&gt; 를 참조하자!&lt;/p&gt;

&lt;p&gt;calico 가 예전의 프로젝트에서 분리되어 나온건지 예전과 달라진 적이 있으므로 공식 홈페이지에서 안내해주는대로 설치하는 것을 권장한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
$ watch kubectl get pods -n calico-system


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후에 위의 커맨드로 모든 calico pod 들의 Status 가 Running 으로 바뀌는지 확인한다. 대략 5~6분 정도 소요되는 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
kubectl taint nodes --all node-role.kubernetes.io/control-plane-
kubectl taint nodes --all node-role.kubernetes.io/master-


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 control plane 의 taint 를 제거함으로써 pod 스케쥴링을 할 수 있도록 바꿔준다.&lt;/p&gt;

&lt;h3 id=&quot;helm-설치&quot;&gt;Helm 설치&lt;/h3&gt;

&lt;p&gt;Helm 은 쿠버네티스의 Package managing tool 이다. Linux 의 APT 나 YUM, 맥에서는 homebrew 와 비슷하다고 보면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
curl -fsSL -o get_helm.sh &amp;lt;https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3&amp;gt;
chmod +x get_helm.sh

helm version


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;worker-node-설정&quot;&gt;Worker Node 설정&lt;/h2&gt;

&lt;p&gt;Master Node 에서 kubeadm init 하면서 얻었던 join 커맨드를 입력해주자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
# 딱히 건들지 않았다면 api-server 의 포트가 6443 으로 설정되어 있을 것이라서 마스터 노드의 6443 포트를 입력한다.
sudo kubeadm join {마스터 노드 IP}:6443 --token {토큰값~}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;join 이 정상적으로 되었다면 master node 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get nodes&lt;/code&gt; 를 입력 했을 때, worker node 들의 상태가 NotReady 가 아닌 Ready 상태여야 한다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Kubernetes" />
      
        <category term="Ansible" />
      
        <category term="ArgoCD" />
      
        <category term="Docker" />
      
        <category term="Linux" />
      

      
        <summary type="html">[Kuploy] Kuploy 는 어떤 프로젝트인가?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Ansible 인벤토리 만들기</title>
      <link href="https://hoex5h.github.io/Ansible_%EC%9D%B8%EB%B2%A4%ED%86%A0%EB%A6%AC_%EB%A7%8C%EB%93%A4%EA%B8%B0" rel="alternate" type="text/html" title="Ansible 인벤토리 만들기" />
      <published>2025-01-14T02:14:00+00:00</published>
      <updated>2025-01-14T02:14:00+00:00</updated>
      <id>https://hoex5h.github.io/Ansible_%EC%9D%B8%EB%B2%A4%ED%86%A0%EB%A6%AC_%EB%A7%8C%EB%93%A4%EA%B8%B0</id>
      <content type="html" xml:base="https://hoex5h.github.io/Ansible_%EC%9D%B8%EB%B2%A4%ED%86%A0%EB%A6%AC_%EB%A7%8C%EB%93%A4%EA%B8%B0">&lt;h1 id=&quot;ansible-앤서블-인벤토리-만들기&quot;&gt;[Ansible] 앤서블 인벤토리 만들기&lt;/h1&gt;

&lt;h2 id=&quot;ansible&quot;&gt;Ansible&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/index.html&quot;&gt;Ansible 공식 문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/inventory_guide/index.html&quot;&gt;Building Ansible Inventories&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;앤서블에는 앞선 포스팅에서 언급했던 앤서블을 실행하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 노드(Control Node)&lt;/code&gt; 와, 앤서블로 관리할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매니지드 노드(Managed Node)&lt;/code&gt; 외에도&lt;/p&gt;

&lt;p&gt;여러가지 개념들이 존재하는데, 이번에 자세히 다룰 개념은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인벤토리&lt;/code&gt; 이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inventory&lt;/code&gt; : 매니지드 노드들의 목록을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인벤토리(Inventory)&lt;/code&gt; 라고 하는데, 각 매니지드 노드들에 대한 IP, 호스트 정보, 변수와 같은 정보를 저장하고 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hosts.ini&lt;/code&gt; 를 작성해보자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
[Worker Nodes]
192.168.0.11
192.168.0.12


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;현재 Kluster 에서 사용중인 Worker Nodes 2개의 고정 ip 값을 적어 주었다.&lt;/p&gt;

&lt;p&gt;이렇게 적는 방법 외에도, 마치 python 의 index slicing 처럼 적는 방법이 있다고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
[Worker Nodes]
192.168.0.[11:50]


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하면 xxx.xxx.xxx.11 ~ xxx.xxx.xxx.50 까지가 포함된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Ansible" />
      

      
        <summary type="html">[Ansible] 앤서블 인벤토리 만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Ansible 시작하기</title>
      <link href="https://hoex5h.github.io/Ansible_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="Ansible 시작하기" />
      <published>2025-01-14T02:14:00+00:00</published>
      <updated>2025-01-14T02:14:00+00:00</updated>
      <id>https://hoex5h.github.io/Ansible_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0</id>
      <content type="html" xml:base="https://hoex5h.github.io/Ansible_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0">&lt;h1 id=&quot;ansible-앤서블-시작하기&quot;&gt;[Ansible] 앤서블 시작하기&lt;/h1&gt;

&lt;h2 id=&quot;ansible&quot;&gt;Ansible&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/index.html&quot;&gt;Ansible 공식 문서&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ansible is an IT automation tool.&lt;br /&gt;
It can configure systems, deploy software,&lt;br /&gt;
and orchestrate more advanced IT tasks such as continuous deployments or zero downtime rolling updates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ansible은 공식 홈페이지의 설명대로 CD(continous deployment) 혹은 실시간 롤링 업데이트와 시스템 및 소프트웨어 배포 등을 위한 자동화 도구이다.&lt;/p&gt;

&lt;p&gt;클러스터를 구축하는데 Ansible 을 쓰기로 결정한 이유는, 클러스터에 새로운 노드들이 추가될 때마다 매번 셋팅 후 join 시킬 수는 없기 때문이다.&lt;/p&gt;

&lt;p&gt;앞으로 무언가를 추가할 때마다 새로운 노드를 셋팅하는 과정이 복잡해지고 시간이 오래 걸리기 때문에 ansible 을 통해 자동화 하는 방법을 택했다.&lt;/p&gt;

&lt;p&gt;Ansible은 관리 되는 노드인 Managed node 와, Ansible 을 직접 실행하며 Managed node 를 관리하는 Control Node 로 나뉜다.
Control Node 와 Managed Node 는 모두 파이썬을 필요로 하며, Managed Node 는 ssh 가 허용되어 있어야 한다.&lt;/p&gt;

&lt;p&gt;Ansible 은 light 버전인 Ansible-core 와, Ansible 로 나뉜다. Kluster 에는 우선 Ansible 을 설치할 것이다.
어느 노드를 Control Node 로 선택할 지 고민을 좀 했는데, 클러스터의 마스터 노드에 직접 Ansible 을 설치하는 것 보다&lt;/p&gt;

&lt;p&gt;기존에 Worker Node 중에서 Jenkins 서버를 설치했던 노드에 통합하는 것이 보안 등 여러가지 이유로 좋을 것 같아 Worker Node3(zenkins) 에 설치하기로 했다.&lt;/p&gt;

&lt;p&gt;공식 홈페이지에서는 pip 를 이용하여 Ansible 을 설치하는 것을 권장하는 것 같다.&lt;/p&gt;

&lt;p&gt;우선 pip 가 설치되어 있는지 확인해보자&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ python3 -m pip -V


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ /usr/bin/python3: No module named pip&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬 설치가 안되어있으니 빠르게 python 을 설치하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ curl &amp;lt;https://bootstrap.pypa.io/get-pip.py&amp;gt; -o get-pip.py
$ python3 get-pip.py --user


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;pip 23.2 from /home/zenkins/.local/lib/python3.10/site-packages/pip (python 3.10)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 한 번 pip 버전을 확인해보니 잘 나오는 모습을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 Ansible 을 설치하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ python3 -m pip install --user ansible
$ python3 -m pip install --user ansible-core==2.12.3


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ansible 과 ansible-core 중에 선택해서 하나만 설치하면 된다. 위에서 언급했듯이 우리는 ansible 을 먼저 사용해보고 lightweight 버전을 사용할 수 있으면 다운그레이드 하려고 한다.&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;실행 결과&lt;/summary&gt;
&lt;code&gt;
&lt;pre&gt;Collecting ansible
Obtaining dependency information for ansible from [https://files.pythonhosted.org/packages/01/43/b5620e57e14a84d9bf257ba4797c2abfa13f7c3be04bc8cd35f86d2e6a2d/ansible-8.1.0-py3-none-any.whl.metadata](https://files.pythonhosted.org/packages/01/43/b5620e57e14a84d9bf257ba4797c2abfa13f7c3be04bc8cd35f86d2e6a2d/ansible-8.1.0-py3-none-any.whl.metadata)
Downloading ansible-8.1.0-py3-none-any.whl.metadata (7.9 kB)
Collecting ansible-core~=2.15.1 (from ansible)
Obtaining dependency information for ansible-core~=2.15.1 from [https://files.pythonhosted.org/packages/80/71/d2582d918dda323ddf998f8e4bdcc35c5b7fabea27917d480670186d3f39/ansible_core-2.15.1-py3-none-any.whl.metadata](https://files.pythonhosted.org/packages/80/71/d2582d918dda323ddf998f8e4bdcc35c5b7fabea27917d480670186d3f39/ansible_core-2.15.1-py3-none-any.whl.metadata)
Downloading ansible_core-2.15.1-py3-none-any.whl.metadata (7.5 kB)
Requirement already satisfied: jinja2&amp;gt;=3.0.0 in /usr/lib/python3/dist-packages (from ansible-core~=2.15.1-&amp;gt;ansible) (3.0.3)
Requirement already satisfied: PyYAML&amp;gt;=5.1 in /usr/lib/python3/dist-packages (from ansible-core~=2.15.1-&amp;gt;ansible) (5.4.1)
Requirement already satisfied: cryptography in /usr/lib/python3/dist-packages (from ansible-core~=2.15.1-&amp;gt;ansible) (3.4.8)
Collecting packaging (from ansible-core~=2.15.1-&amp;gt;ansible)
Downloading packaging-23.1-py3-none-any.whl (48 kB)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 48.9/48.9 kB 579.9 kB/s eta 0:00:00
Collecting resolvelib&amp;lt;1.1.0,&amp;gt;=0.5.3 (from ansible-core~=2.15.1-&amp;gt;ansible)
Downloading resolvelib-1.0.1-py2.py3-none-any.whl (17 kB)
Downloading ansible-8.1.0-py3-none-any.whl (44.8 MB)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 44.8/44.8 MB 1.1 MB/s eta 0:00:00
Downloading ansible_core-2.15.1-py3-none-any.whl (2.2 MB)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.2/2.2 MB 1.1 MB/s eta 0:00:00
DEPRECATION: distro-info 1.1build1 has a non-standard version number. pip 23.3 will enforce this behaviour change. A possible replacement is to upgrade to a newer version of distro-info or contact the author to suggest that they release a version with a conforming version number. Discussion can be found at [https://github.com/pypa/pip/issues/12063](https://github.com/pypa/pip/issues/12063)
DEPRECATION: python-debian 0.1.43ubuntu1 has a non-standard version number. pip 23.3 will enforce this behaviour change. A possible replacement is to upgrade to a newer version of python-debian or contact the author to suggest that they release a version with a conforming version number. Discussion can be found at [https://github.com/pypa/pip/issues/12063](https://github.com/pypa/pip/issues/12063)
Installing collected packages: resolvelib, packaging, ansible-core, ansible
WARNING: The scripts ansible, ansible-config, ansible-connection, ansible-console, ansible-doc, ansible-galaxy, ansible-inventory, ansible-playbook, ansible-pull and ansible-vault are installed in &apos;/home/zenkins/.local/bin&apos; which is not on PATH.
Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
WARNING: The script ansible-community is installed in &apos;/home/zenkins/.local/bin&apos; which is not on PATH.
Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
Successfully installed ansible-8.1.0 ansible-core-2.15.1 packaging-23.1 resolvelib-1.0.1
&lt;/pre&gt;&lt;/code&gt;
&lt;/details&gt;

&lt;p&gt;Ansible 을 업그레이드 하기 위해서는 단순히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--upgrade&lt;/code&gt; 만 붙이면 된다고 한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ python3 -m pip install --upgrade --user ansible


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ansible-core 버전 확인은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ ansible --version


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ansible 버전 확인은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
python3 -m pip show ansible


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;을 통해서 하면 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Ansible" />
      

      
        <summary type="html">[Ansible] 앤서블 시작하기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Ansible 설정하기</title>
      <link href="https://hoex5h.github.io/Ansible_%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="Ansible 설정하기" />
      <published>2025-01-14T02:14:00+00:00</published>
      <updated>2025-01-14T02:14:00+00:00</updated>
      <id>https://hoex5h.github.io/Ansible_%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0</id>
      <content type="html" xml:base="https://hoex5h.github.io/Ansible_%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0">&lt;h1 id=&quot;ansible-앤서블-설정하기&quot;&gt;[Ansible] 앤서블 설정하기&lt;/h1&gt;

&lt;h2 id=&quot;ansible&quot;&gt;Ansible&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/index.html&quot;&gt;Ansible 공식 문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ansible.cfg 파일을 수정하여 여러가지 설정을 하려고 할 때, pip 로 설치한 경우 공식 문서에서 example file 을 제공한다길래 들어가봤더니&lt;/p&gt;

&lt;p&gt;파일이 삭제되어 있었다…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Starting with Ansible version 2.4, you can use the ansible-config command line utility to list your available options and inspect the current values.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아무래도 ansible 2.4 이후로는 ansible-config 커맨드 라인을 통해 설정을 하는 것 같다.&lt;/p&gt;

&lt;p&gt;2023년 7월달 기준으로 ansible 이 8.1 버전인걸 보아하니, 아마도 한참 전에 바뀌었나보다.&lt;/p&gt;

&lt;p&gt;Ansible 은 아래와 같은 순서대로 cfg 파일을 찾는다고 하는데, 우선 /etc/ansible 에 간단한 sample cfg 파일을 생성하기로 했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANSIBLE_CONFIG&lt;/code&gt; (env 변수가 설정되어 있을 경우)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ansible.cfg&lt;/code&gt; (현재 디렉토리에서)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.ansible.cfg&lt;/code&gt; (home 디렉토리에서)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ansible/ansible.cfg&lt;/code&gt; (Default 값 인듯)&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;sample ansible.cfg 파일을 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ ansible-config init --disabled &amp;gt; ansible.cfg
$ ansible-config init --disabled -t all &amp;gt; ansible.cfg


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어 둘 중에 하나를 선택하면 되는데, 둘 다 주석으로 자세히 설명해둔 sample config 파일을 만들어준다고 하고 아래의 명령어가&lt;/p&gt;

&lt;p&gt;현재 존재하는 plugin 까지 포함하는 방법이라고 한다.&lt;/p&gt;

&lt;p&gt;꽤나 많은 옵션이 존재해서, 필요할 때마다 수정해야겠다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings&quot;&gt;공식 문서 옵션 설명&lt;/a&gt;&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;ansible.cfg&lt;/summary&gt;
&lt;code&gt;
&lt;pre&gt;
[ter!
efaults]


# (boolean) By default Ansible will issue a warning when received from a task action (module or action plugin)


# These warnings can be silenced by adjusting this setting to False.


;action_warnings=True


# (list) Accept list of cowsay templates that are &apos;safe&apos; to use, set to empty list if you want to enable all installed templates.


;cowsay_enabled_stencils=bud-frogs, bunny, cheese, daemon, default, dragon, elephant-in-snake, elephant, eyes, hellokitty, kitty, luke-koala, meow, milk, moofasa, moose, ren, sheep, small, stegosaurus, stimpy, supermilker, three-eyes, turkey, turtle, tux, udder, vader-koala, vader, www


# (string) Specify a custom cowsay path or swap in your cowsay implementation of choice


;cowpath=


# (string) This allows you to chose a specific cowsay stencil for the banners or use &apos;random&apos; to cycle through them.


;cow_selection=default


# (boolean) This option forces color mode even when running without a TTY or the &quot;nocolor&quot; setting is True.


;force_color=False


# (path) The default root path for Ansible config files on the controller.


;home=~/.ansible


# (boolean) This setting allows suppressing colorizing output, which is used to give a better indication of failure and status information.


;nocolor=False


# (boolean) If you have cowsay installed but want to avoid the &apos;cows&apos; (why????), use this.


;nocows=False


# (boolean) Sets the default value for the any_errors_fatal keyword, if True, Task failures will be considered fatal errors.


;any_errors_fatal=False


# (path) The password file to use for the become plugin. --become-password-file.


# If executable, it will be run and the resulting stdout will be used as the password.


;become_password_file=


# (pathspec) Colon separated paths in which Ansible will search for Become Plugins.


;become_plugins={ ANSIBLE_HOME ~ &quot;/plugins/become:/usr/share/ansible/plugins/become&quot; } 


# (string) Chooses which cache plugin to use, the default &apos;memory&apos; is ephemeral.


;fact_caching=memory


# (string) Defines connection or path information for the cache plugin


;fact_caching_connection=


# (string) Prefix to use for cache plugin files/tables


;fact_caching_prefix=ansible_facts


# (integer) Expiration timeout for the cache plugin data


;fact_caching_timeout=86400


# (list) List of enabled callbacks, not all callbacks need enabling, but many of those shipped with Ansible do as we don&apos;t want them activated by default.


;callbacks_enabled=


# (string) When a collection is loaded that does not support the running Ansible version (with the collection metadata key `requires_ansible`).


;collections_on_ansible_version_mismatch=warning


# (pathspec) Colon separated paths in which Ansible will search for collections content. Collections must be in nested _subdirectories_, not directly in these directories. For example, if `COLLECTIONS_PATHS` includes `&apos;{ ANSIBLE_HOME ~ &quot;/collections&quot; }&apos;`, and you want to add `my.collection` to that directory, it must be saved as `&apos;{ ANSIBLE_HOME} ~ &quot;/collections/ansible_collections/my/collection&quot; }&apos;`.


;collections_path={ ANSIBLE_HOME ~ &quot;/collections:/usr/share/ansible/collections&quot; }


# (boolean) A boolean to enable or disable scanning the sys.path for installed collections


;collections_scan_sys_path=True


# (path) The password file to use for the connection plugin. --connection-password-file.


;connection_password_file=


# (pathspec) Colon separated paths in which Ansible will search for Action Plugins.


;action_plugins={ ANSIBLE_HOME ~ &quot;/plugins/action:/usr/share/ansible/plugins/action&quot; }
&lt;/pre&gt;&lt;/code&gt;
&lt;/details&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Ansible" />
      

      
        <summary type="html">[Ansible] 앤서블 설정하기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Ansible Managed Node 에서의 ssh 설정</title>
      <link href="https://hoex5h.github.io/Ansible_Managed_Node_%EC%97%90%EC%84%9C%EC%9D%98_ssh_%EC%84%A4%EC%A0%95" rel="alternate" type="text/html" title="Ansible Managed Node 에서의 ssh 설정" />
      <published>2025-01-14T02:14:00+00:00</published>
      <updated>2025-01-14T02:14:00+00:00</updated>
      <id>https://hoex5h.github.io/Ansible_Managed_Node_%EC%97%90%EC%84%9C%EC%9D%98_ssh_%EC%84%A4%EC%A0%95</id>
      <content type="html" xml:base="https://hoex5h.github.io/Ansible_Managed_Node_%EC%97%90%EC%84%9C%EC%9D%98_ssh_%EC%84%A4%EC%A0%95">&lt;h1 id=&quot;ansible-managed-node-에서의-ssh-설정&quot;&gt;[Ansible] Managed Node 에서의 ssh 설정&lt;/h1&gt;

&lt;h2 id=&quot;ssh&quot;&gt;SSH&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/index.html&quot;&gt;Ansible 공식 문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.ansible.com/ansible/latest/inventory_guide/index.html&quot;&gt;Building Ansible Inventories&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;우선 테스트로 진행할 Worker Node 1 에, ansible 이 ssh로 접근해서 사용할 사용자 계정을 하나 만들어주었다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ sudo adduser ansible
$ sudo passwd ansible


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;이후 ansible 계정이 sudo 권한을 비밀번호 없이 사용할 수 있도록 설정했다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ sudo visudo

...
# User privilege specification
root    ALL=(ALL:ALL) ALL
ansible ALL=(ALL:ALL) NOPASSWD:ALL
...


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Control Node 에 sshpass 를 설치한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ sudo apt-get install sshpass


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Control Node 에서 공개키/개인키 를 생성한다.
공개키/ 개인키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/home/{user}/.ssh&lt;/code&gt; 에 성생된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ sudo ssh-keygen


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;공개키/개인키를 Managed Node 에 보내기&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ ssh-copy-id -p {port} ansible@{ip_address}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ssh-copy-id -p 6001 &lt;a href=&quot;mailto:ansible@192.168.0.11&quot;&gt;ansible@192.168.0.11&lt;/a&gt;
Managed Node 에서 ssh 포트를 바꾸었기 때문에 -p 옵션을 사용했다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Ansible" />
      

      
        <summary type="html">[Ansible] Managed Node 에서의 ssh 설정</summary>
      

      
      
    </entry>
  
</feed>
