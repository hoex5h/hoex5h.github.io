<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://hoex5h.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hoex5h.github.io/" rel="alternate" type="text/html" /><updated>2025-01-15T11:18:34+00:00</updated><id>https://hoex5h.github.io/feed.xml</id><title type="html">hoeeeeeh</title><subtitle>HOEH 개발 블로그</subtitle><entry><title type="html">Effective TypeScript - 2</title><link href="https://hoex5h.github.io/Effective_TypeScript_-_2" rel="alternate" type="text/html" title="Effective TypeScript - 2" /><published>2025-01-14T03:54:00+00:00</published><updated>2025-01-14T03:54:00+00:00</updated><id>https://hoex5h.github.io/Effective_TypeScript_-_2</id><content type="html" xml:base="https://hoex5h.github.io/Effective_TypeScript_-_2">&lt;blockquote&gt;
  &lt;p&gt;이펙티브 타입스크립트 책과&lt;br /&gt;
이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;타입스크립트-컴파일러-역할&quot;&gt;타입스크립트 컴파일러 역할&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;구 버전 브라우저를 위한 트랜스파일 -&amp;gt; Babel 의 역할이었던거 같은데?&lt;/li&gt;
  &lt;li&gt;코드의 타입 오류 체크&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 역할은 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적&lt;/code&gt;이다. 서로의 작업에 영향을 주지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;타입-오류가-있어도-컴파일이-가능&quot;&gt;타입 오류가 있어도 컴파일이 가능&lt;/h2&gt;

&lt;p&gt;컴파일은 타입 체크와 독립적으로 동작하므로 오류 있어도 컴파일은 가능&lt;/p&gt;

&lt;p&gt;만약 오류가 있을 때 컴파일 하고 싶지 않으면 tsconfig.json 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noEmitError&lt;/code&gt; 옵션을 true 로 주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;런타임에는-타입-체크-불가능&quot;&gt;런타임에는 타입 체크 불가능&lt;/h2&gt;

&lt;p&gt;타입스크립트에서 자바스크립트로 컴파일되면서 타입이나 인터페이스 같은 경우 전부 제거된다.
즉, 런타임 시점에서 타입과 인터페이스는 아무런 역할을 하지 못한다.&lt;/p&gt;

&lt;h2 id=&quot;함수-오버로딩-불가능&quot;&gt;함수 오버로딩 불가능&lt;/h2&gt;

&lt;p&gt;선언문은 타입 별로 여러개 선언은 가능하다. 하지만 구현체는 오직 하나다.&lt;/p&gt;

&lt;h2 id=&quot;덕타이핑&quot;&gt;덕타이핑&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://hoeeeeeh.github.io/javascript/2024/07/29/day1112.html#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-interface-duck-typing&quot;&gt;interface 와 duck-typing&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;any-타입-꼭-써야겠어&quot;&gt;Any 타입, 꼭 써야겠어?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;any 타입 쓰면 타입에 안전성이 없다. 쓰면 number 타입에 string 이 할당될 수도 있어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 함수의 시그니처(약속/의도 정도로 해석?)가 무시된다.&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 자동완성 기능, 코드 리팩토링 도구 쓰기 힘들어져 -&amp;gt; 생산성 떨어진다!&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 코드 리팩토링할 때 버그를 찾기 힘들어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 타입 설계의 의도, 상태 등이 감춰져서 설계를 해석하기 힘들어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 실수가 빈번해져&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이래도 any 타입, 꼭 사용하셔야겠습니까?&lt;/p&gt;

&lt;p&gt;근데 불가피하게 any 타입을 꼭 써야할 때가 있다. 이는 5장에서 다룬다.&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="TypeScript" /><summary type="html">이펙티브 타입스크립트 책과 이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.</summary></entry><entry><title type="html">Effective TypeScript - 1</title><link href="https://hoex5h.github.io/Effective_TypeScript_-_1" rel="alternate" type="text/html" title="Effective TypeScript - 1" /><published>2025-01-14T03:52:00+00:00</published><updated>2025-01-14T03:52:00+00:00</updated><id>https://hoex5h.github.io/Effective_TypeScript_-_1</id><content type="html" xml:base="https://hoex5h.github.io/Effective_TypeScript_-_1">&lt;blockquote&gt;
  &lt;p&gt;이펙티브 타입스크립트 책과&lt;br /&gt;
이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;ts-js&quot;&gt;TS, JS&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입스크립트는 자바스크립트의 상위 집합&lt;/code&gt; 이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입스크립트는 타입이 정의된 자바스크립트의 상위 집합이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;모든 JS 프로그램이 TS 라는 명제는 참, 반대는 성립하지 않는다.&lt;/p&gt;

&lt;h1 id=&quot;ts-타입체커&quot;&gt;TS 타입체커&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
// ts
let sample = &quot;this is a sample&quot;;
console.log(sample.uppercase());
// uppercase 라는 메소드가 string 형식에 없다!
// toUpperCase() 를 사용하시겠습니까?


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런식으로 sample 이 string 이라는걸 명시해주지 않아도 타입스크립트는 초기값으로부터 추론한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;코드의 의도가 무엇인지 타입 구문을 통해 타입스크립트에게 알려줄 수 있기 때문에 코드의 동작과 의도가 다른 부분을 찾을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코드의 의도를 표현하려면 명시적으로 선언해라 ex) interface&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
interface person {
  name: string;
  age: number;
}

const people: Person[] = [
  // Person 예시
  { name: &quot;John&quot;, age: 5 },
  //...
];


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;자동-형변환-체크&quot;&gt;자동 형변환 체크?&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
const a = 2 + &quot;3&quot;; // 자바스크립트 런타임에서 정상, String 타입의 &apos;23&apos;
const b = null + 7; // 자바스크립트 런타임에서 정상, Number 타입의 7, 그러나 typescript 는 오류를 발생시킴
const c = [] + 12; // 자바스크립트 런타임에서 정상, String 타입의 &apos;12&apos;, 그러나 typescript 는 오류를 발생시킴
// 근데 이건 왜 String 타입이 되는걸까?
alert(&quot;Hi&quot;, &quot;world&quot;); // 자바스크립트 런타임에서 정상, 앞의 &quot;Hi&quot; 만 나옴. 하지만 alert는 arg가 0개~1개 인데 2개를 가져왔다고 ts 오류


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;모든걸-다-잡아주지는-않는다&quot;&gt;모든걸 다 잡아주지는 않는다.&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
const a = [&quot;hi&quot;];
console.log(a[2]); // 컴파일은 정상, 런타임에서 오류


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문법의 엄격함은 온전히 취향의 차이이다.&lt;/p&gt;

&lt;h1 id=&quot;타입스크립트-컴파일러의-셋팅에-따라-바뀐다&quot;&gt;타입스크립트 컴파일러의 셋팅에 따라 바뀐다.&lt;/h1&gt;

&lt;p&gt;tsconfig.json 파일에서 여러 옵션으로 셋팅을 줄 수 있다. 타입스크립트를 어떻게 사용할 지 동료들에게 알려줄 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noImplicitAny&lt;/code&gt; 옵션은 타입 선언이 없으면 암시적으로 any 타입으로 선언하는 옵션인데, false 와 true 로 옵션을 켜고 끌 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strictNullChecks&lt;/code&gt; 는 모든 타입에 null 과 undefined 를 할당할 수 있는지에 대한 옵션이다.&lt;/p&gt;

&lt;p&gt;null 을 명시적으로 허용하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const x : number | null = null;&lt;/code&gt; 처럼 사용하는 것이 좋다. 만약 이렇게 되면 Null check 를 위한 assertion(단언문) 이 필요하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
if (x.abc) {
  // null 이 아닐때
}
x!.abc; // x가 Null 이 아니라고 단언한다


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;웬만하면 noImplicit, strictNullChecks 는 설정해두고 시작해라. 안그러면 undefined is not a Object 오류를 계속 만날 것이다.&lt;/p&gt;

&lt;p&gt;엄격하게 잡고 싶으면 그냥 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strict&lt;/code&gt; 옵션을 true 로 줘라.&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="TypeScript" /><summary type="html">이펙티브 타입스크립트 책과 이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.</summary></entry><entry><title type="html">[Swift] @AppStorage</title><link href="https://hoex5h.github.io/Swift-_@AppStorage" rel="alternate" type="text/html" title="[Swift] @AppStorage" /><published>2025-01-14T03:52:00+00:00</published><updated>2025-01-14T03:52:00+00:00</updated><id>https://hoex5h.github.io/%5BSwift%5D_@AppStorage</id><content type="html" xml:base="https://hoex5h.github.io/Swift-_@AppStorage">&lt;h1 id=&quot;appstorage&quot;&gt;@AppStorage&lt;/h1&gt;

&lt;p&gt;Swift 에서도 코틀린처럼 기기 내부에 데이터를 저장할 수 있는 방법이 있다.&lt;/p&gt;

&lt;p&gt;코틀린에서는 SharedPreference 를 사용했었는데, Swift 에서는 @AppStorage 를 사용한다.&lt;/p&gt;

&lt;p&gt;다만 차이점이 있었는데,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
@AppStorage(&quot;onboarding&quot;) var isOnboardingViewActive : Bool = true


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드대로만 보면 어느 파일에서든 “onboarding” 프로퍼티를 사용하려면 true(혹은 false) 로 초기화를 해야하는 것처럼 보인다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사실은 계속 초기화가 되는 것이 아니라, 기기 내부 저장소에서 onboarding 프로퍼티를 찾지 못하는 경우에만 true로 초기화 한다는 뜻이고, 이미 존재한다면 해당 초기화 구문은 무시된다고 한다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="Swift" /><summary type="html">@AppStorage</summary></entry><entry><title type="html">[Swift] Cocoa Pod install Error</title><link href="https://hoex5h.github.io/Swift-_Cocoa_Pod_install_Error" rel="alternate" type="text/html" title="[Swift] Cocoa Pod install Error" /><published>2025-01-14T03:52:00+00:00</published><updated>2025-01-14T03:52:00+00:00</updated><id>https://hoex5h.github.io/%5BSwift%5D_Cocoa_Pod_install_Error</id><content type="html" xml:base="https://hoex5h.github.io/Swift-_Cocoa_Pod_install_Error">&lt;h1 id=&quot;cocoa-pod-install-error&quot;&gt;Cocoa Pod install Error&lt;/h1&gt;

&lt;h2 id=&quot;에러-내용&quot;&gt;에러 내용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
You may have encountered a bug in the Ruby interpreter or extension libraries.
Bug reports are welcome.
For details: &amp;lt;https://www.ruby-lang.org/bugreport.html&amp;gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;원인&quot;&gt;원인&lt;/h3&gt;

&lt;p&gt;M1 맥북에서 일어나는 버그라고 하는데,, M1이 출시한지 이렇게나 오래 되었는데 아직도 ㅠ&lt;/p&gt;

&lt;h2 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ sudo arch -x86_64 gem install ffi
$ arch -x86_64 pod install


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 해서 해결할 수 있다고 한다.&lt;/p&gt;</content><author><name></name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="Swift" /><summary type="html">Cocoa Pod install Error</summary></entry><entry><title type="html">Dependency Injection</title><link href="https://hoex5h.github.io/Dependency_Injection" rel="alternate" type="text/html" title="Dependency Injection" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/Dependency_Injection</id><content type="html" xml:base="https://hoex5h.github.io/Dependency_Injection">&lt;p&gt;Dependency Injection ( Angular 공식 문서 )&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.nestjs.com/providers&quot;&gt;nest.js 공식문서&lt;/a&gt;를 읽어보는 도중 DI 관련한 문서에 대한 링크로 &lt;a href=&quot;https://www.angular.kr/guide/dependency-injection&quot;&gt;Angular 의 공식 문서&lt;/a&gt;를 걸려있었다.&lt;/p&gt;

&lt;p&gt;자세하게, 한국어로도 적혀있는 것 같아서 nestjs 를 쓰기 전에 꼼꼼히 읽어보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;의존성-주입은-왜-사용할까&quot;&gt;의존성 주입은 왜 사용할까?&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dependency Injection, or DI, is a design pattern and mechanism for creating and delivering some parts of an application to other parts of an application that require them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;의존성 주입은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션의 일부(A)&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;또 다른 곳(B)&lt;/code&gt;에서 필요로 할 때, A 를 만들고 전달하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;즉 다른 클래스에 있는 기능을 사용하고 싶을 때 의존성을 주입해주는 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;의존성을-사용하는-쪽-제공하는-쪽&quot;&gt;의존성을 사용하는 쪽, 제공하는 쪽&lt;/h1&gt;

&lt;p&gt;단순하게 의존성을 주입 하는 것은 어떤 방식으로든 하나의 객체에 다른 클래스의 객체를 넘기기만 해도 의존성 주입이라고 부를 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class Foo {
    constructor(){
        // ...
    }
}

class UsingDI {
    constructor(private injectClass)
}

class DoNotUseDI {
    constructor(){
        this.injectClass = new Foo();
    }
}



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시대로라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DoNotUseDI&lt;/code&gt; 객체는 직접 Foo 객체를 생성해서 사용한다.&lt;/p&gt;

&lt;p&gt;따라서 아주 강한 결합을 가지게 되는데, 만약 나중에 Foo 가 아니라 Bar 라는 클래스로 바꾸고 싶다고 하면
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DoNotUseDI&lt;/code&gt; 클래스의 코드도 수정해야하고 테스트할 때도 꼭 Foo 객체를 넣어줘야 하기 때문에 복잡해지게 될 것이다.&lt;/p&gt;

&lt;p&gt;반면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UsingDI&lt;/code&gt; 클래스는 생성자로 어떤 객체를 넘기느냐에 따라, 그 객체에 결합이 생긴다. 위의 예시에 비해 더 동적으로 의존성이 생긴다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 Foo 의존성을 주입했다가, 나중에는 Bar 객체를 주입할 수도 있고, 또 나중에는 어떤 객체라도 덕타이핑에 문제가 없다면 (일단은) 주입할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;또한 테스트할 때도 굳이 실제 객체를 넣어줄 필요 없이 간단한 모킹 객체를 넣어줄 수도 있을 것이다.&lt;/p&gt;

&lt;p&gt;다만 여기서 기억해두어야 할 점은 의존성은 사용하는 쪽(주입 당하는 쪽) 과 제공하는 쪽(주입하는 쪽) 이 있다는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;의존성-주입&quot;&gt;의존성 주입&lt;/h1&gt;

&lt;h2 id=&quot;injector&quot;&gt;Injector&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;injector&lt;/code&gt; 객체는, 미리 생성된 프로바이더(의존성을 제공당할 수 있는 클래스) 대로 의존성 객체를 생성하고 캐싱해둔다.&lt;/p&gt;

&lt;p&gt;또한 인젝터는 (기본적으로) 의존성 객체들을 싱글톤 인스턴스로 관리한다.&lt;/p&gt;

&lt;h2 id=&quot;모듈에-따라&quot;&gt;모듈에 따라?&lt;/h2&gt;

&lt;p&gt;NestJS 의 컴포넌트는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모듈&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로바이더&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨트롤러&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스&lt;/code&gt; 등으로 계층을 나눌 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
@Module({
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}

@Module({
  imports: [CatsModule],
  controllers: [DogsController],
})
export class DogsModule {}



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시처럼 NestJS 모듈 별로 프로바이더, 서비스, 컨트롤러 등등을 주입받는데 모듈별로 injector 가 생성되고 해당 인젝터가 의존성 객체들을 캐싱하고 있다.&lt;/p&gt;

&lt;p&gt;또한 CatsModule 에 주입된 CatsService 를 export 함으로써 DogsModule 에서 CatsModule 의 프로바이더를 가져와서 사용할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;injectable--의존성-주입-가능&quot;&gt;@Injectable : 의존성 주입 가능&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
@Injectable
class CatService {}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래스를 의존성으로 주입하려면 가장 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Injectable&lt;/code&gt; 데코레이터를 사용해야한다.&lt;/p&gt;

&lt;h2 id=&quot;module--의존성-등록&quot;&gt;@Module : 의존성 등록&lt;/h2&gt;

&lt;p&gt;NestJs 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Module&lt;/code&gt; 로 의존성을 등록해줄 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;프로바이더-scope&quot;&gt;프로바이더 Scope&lt;/h2&gt;

&lt;p&gt;의존성 객체가 되는 프로바이더의 생명 주기는 애플리케이션의 생명 주기와 같다. 애플리케이션이 부트스트랩 될 때, 모든 의존성은 해결(사용 가능)이 되어야 한다.
그렇기 때문에 애플리케이션이 부트스트랩 될 때, 모든 프로바이더들이 인스턴트화 되어야 하고 애플리케이션이 종료될 때 모든 프로바이더들은 제거된다.&lt;/p&gt;

&lt;p&gt;만약 프로바이더의 Scope 를 직접 정하고 싶다면, &lt;a href=&quot;https://docs.nestjs.com/fundamentals/injection-scopes&quot;&gt;request-scoped&lt;/a&gt; 의 방법을 사용할 수 있다고도 한다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="TypeScript" /><category term="NestJS" /><summary type="html">Dependency Injection ( Angular 공식 문서 )</summary></entry><entry><title type="html">Express.js 따라 만들기</title><link href="https://hoex5h.github.io/Express.js_%EB%94%B0%EB%9D%BC_%EB%A7%8C%EB%93%A4%EA%B8%B0" rel="alternate" type="text/html" title="Express.js 따라 만들기" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/Express.js_%EB%94%B0%EB%9D%BC_%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="https://hoex5h.github.io/Express.js_%EB%94%B0%EB%9D%BC_%EB%A7%8C%EB%93%A4%EA%B8%B0">&lt;p&gt;ts/js 로 express 따라 만들기&lt;/p&gt;

&lt;h1 id=&quot;tsjs-로-express-따라-만들기&quot;&gt;ts/js 로 express 따라 만들기&lt;/h1&gt;

&lt;p&gt;node 로 웹 서버를 만들때부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;express&lt;/code&gt; 를 자주 사용했었는데 express 의 내부 동작은 잘 알지 못한채로 그저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.use&lt;/code&gt; 를 사용했던 것 같다.&lt;/p&gt;

&lt;p&gt;그래서 이번 기회에 express 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt; 으로 구현해보려고 한다.&lt;/p&gt;

&lt;h2 id=&quot;http-모듈이-아니라-왜-socket-을-사용해야할까&quot;&gt;http 모듈이 아니라 왜 socket 을 사용해야할까?&lt;/h2&gt;

&lt;p&gt;일단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹 서버&lt;/code&gt; 라는걸 생각해보면 당연히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http&lt;/code&gt; 모듈을 사용하는 것이 편하다.&lt;/p&gt;

&lt;p&gt;소켓으로 구현한다고 해도 클라이언트가 http 프로토콜로 보낸다면 웹 서버에서도 소켓을 http 모듈처럼 사용해야할 것이다.&lt;/p&gt;

&lt;p&gt;그럼에도 socket 으로 구현해보면 좋은 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결국 http 통신도 소켓 통신&lt;/code&gt; 이라는 것이다.&lt;/p&gt;

&lt;p&gt;node 의 &lt;a href=&quot;https://nodejs.org/api/http.html#class-httpserver&quot;&gt;http 모듈&lt;/a&gt;에서 서버를 생성할 때, 결국 &lt;a href=&quot;https://nodejs.org/api/net.html#class-netserver&quot;&gt;소켓 모듈&lt;/a&gt; 을 상속받아서 사용한다.&lt;/p&gt;

&lt;p&gt;소켓 모듈은 &lt;a href=&quot;https://nodejs.org/api/events.html#class-eventemitter&quot;&gt;EventEmitter&lt;/a&gt; 모듈을 상속받는데, 데이터가 들어오거나 소켓 연결이 생성되거나 끊어졌을 때 등의 이벤트가 발생하게끔 만들어졌기 때문이다.&lt;/p&gt;

&lt;p&gt;그래서 소켓을 활용한다는것은 node.js 개발자로서 가장 아래까지 내려가볼 수 있는 기회라고 생각한다.&lt;/p&gt;

&lt;p&gt;추후에는 handshake 과정까지 만들어보고싶다.&lt;/p&gt;

&lt;p&gt;그래도 추후에 꼭 네트워크 공부는 추가로 하자..&lt;/p&gt;

&lt;h2 id=&quot;socket-으로-listen&quot;&gt;Socket 으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Listen&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Socket 으로 Express 를 구현하기로 했으니 당연하게도 socket 을 활용해서 서버를 만들어야한다.&lt;/p&gt;

&lt;p&gt;이는 위에서 언급했던 node 의 &lt;a href=&quot;https://nodejs.org/api/net.html#class-netserver&quot;&gt;net.server&lt;/a&gt; 를 활용하면 된다.&lt;/p&gt;

&lt;p&gt;여기서 우리가 만들 Express 가 net.server 를 상속받을지, 아니면 net.Server 객체를 그냥 사용할지에 대해서 고민을 할 수 있는데
net.Server 를 상속받는다는 것은 net.Server 의 메소드를 오버라이딩 한다든지, 추가 메소드를 만드는 등의 작업이 있을 경우 유효하다고 생각한다.&lt;/p&gt;

&lt;p&gt;우리의 커스텀 Express 에서는 net.Server 의 메소드들을 사용할 것이지, 추가로 메소드를 생성/변경 등을 하지 않을 것 같아서 상속 받지는 않을 예정이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
import net from &apos;net&apos;;

class Express {

  listen(port: number, callback: () =&amp;gt; void) {

    const server = net.createServer((socket) =&amp;gt; {
      socket.on(&apos;data&apos;, (data) =&amp;gt; {
        /*
            ...
            TODO: socket 으로 넘어온 Request 를 Express 에서 쓸 수 있도록 파싱
            ...
        */
      });
    });

    server.listen(port, () =&amp;gt; {
      callback();
    });

  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;net.CreateServer 를 통해서 tcp 연결을 만들고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생했을 때 데이터들을 가지고 우리가 사용하기 편하도록 파싱하는 과정을 거치면 될 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;-socket-은-stream-이다&quot;&gt;🤔 socket 은 stream 이다!&lt;/h3&gt;

&lt;p&gt;여기서 생각해보면 좋을 점은 socket 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream&lt;/code&gt; 을 활용한다.&lt;/p&gt;

&lt;p&gt;node 의 &lt;a href=&quot;https://nodejs.org/api/net.html#class-netsocket&quot;&gt;net.Socket&lt;/a&gt; 은 &lt;a href=&quot;https://nodejs.org/api/stream.html#class-streamduplex&quot;&gt;stream.Duplex&lt;/a&gt; 를 상속받아서 사용하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream 에 대한 정리는 여기서 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 클라이언트가 보낸 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든 데이터&lt;/code&gt; 가 수신될 때까지 기다리는게 아니라 stream 으로 (순차적으로) 데이터가 들어오면 그 즉시 버퍼에 쌓이고
버퍼에 데이터가 일정량 이상 쌓일 때마다 chunk 단위로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생한다.&lt;/p&gt;

&lt;p&gt;(보통은 버퍼가 넘치기 전에, 혹은 데이터가 전부 다 들어왔을 때 ‘data’ 이벤트가 발생한다.)&lt;/p&gt;

&lt;p&gt;다시 말해서 들어오는 데이터가 크다면 데이터가 나누어져서 들어올 수 있다 ( === 한 번의 통신에 여러 번의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생할 수 있다) 는 이야기이다.&lt;/p&gt;

&lt;p&gt;따라서 buffer 의 크기보다 큰 데이터를 클라이언트에서 보냈다면, 여러 번의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;실시간으로 데이터를 처리해야하는(ex. 유튜브 같은 영상 스트림) 경우에는 들어오는 데이터마다 처리를 해주면 된다.&lt;/p&gt;

&lt;p&gt;반면에 용량이 매우 큰 이미지/동영상 파일은 모든 chunk 들을 다 합쳐서 하나로 만들어야할 것이다.&lt;/p&gt;

&lt;p&gt;이에 대한 처리까지 있으면 좋을 것 같다!&lt;/p&gt;

&lt;h2 id=&quot;소켓-통신을-http-통신-처럼&quot;&gt;소켓 통신을 http 통신 처럼&lt;/h2&gt;

&lt;p&gt;http 모듈을 사용한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소켓 통신으로 들어오는 Request&lt;/code&gt; 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Express 의 Request&lt;/code&gt; 처럼 바꿔줄 필요가 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 socket 으로 들어온 HTTP Request 는 아래처럼 들어올 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
GET /favicon.ico HTTP/1.1
Host: localhost:3000
Connection: keep-alive
sec-ch-ua-platform: &quot;macOS&quot;
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36
sec-ch-ua: &quot;Chromium&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;
DNT: 1
sec-ch-ua-mobile: ?0
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: image
Referer: &amp;lt;http://localhost:3000/index.html&amp;gt;
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Cookie: sid=1234; coo=11

helloworld this is a body


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하나의 거대한 문자열을 잘 파싱해서 우리의 express 에서 쓰기 편하도록 쉽게 만드는 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;파싱의 큰 기준은 두 가지 이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Header 와 Body 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\r\\n\\r\\n&lt;/code&gt; 으로 구분된다.&lt;/li&gt;
  &lt;li&gt;Header 끼리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\r\\n&lt;/code&gt; 으로 구분된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;맨 윗 줄을 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET /favicon.ico HTTP/1.1&lt;/code&gt; 이라고 나오는데&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Method&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Version&lt;/code&gt; 으로 구분해주어 아래 처럼 하나의 객체로 만들어주자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class ExpressRequest {
  headers?: Header;

  body: string | object = &apos;&apos;;

  method?: string;

  // 전체 url
  url?: string;

  protocol?: string;

  version?: string;
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-url-의-query-부분이나-params-부분도-처리하자&quot;&gt;🤔 url 의 Query 부분이나 Params 부분도 처리하자&lt;/h3&gt;

&lt;h3 id=&quot;params&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Params&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;실제로 express 를 써보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.use(&apos;/card/:username/:cardId, ...)&lt;/code&gt; 와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; 를 사용하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;사용자가 Request 를 보낼 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/card/hoeh/3?columnId=5&amp;amp;columnName=today&lt;/code&gt; 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; 문자 이후에 있는 query 도 있을 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 위에서 파싱한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url&lt;/code&gt; 부분에서 query, param 부분도 분리해주면 좋을 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class ExpressRequest {
  headers?: Header;

  body: string | object = &apos;&apos;;

  method?: string;

  // 전체 url
  url?: string;

  protocol?: string;

  version?: string;

  // 여기까지가 SocketRequest

  // /user/:id 에서 id
  params: object = {};

  // /search?keyword=naver { keyword : naver }
  query: object = {};

  // /user?id=123 에서 /user
  path?: string;
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로, url 로 부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;params&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 까지 파싱해서 Request 에 넣어주도록 하자.&lt;/p&gt;

&lt;p&gt;파싱할 때는 node 의 &lt;a href=&quot;https://nodejs.org/api/querystring.html&quot;&gt;querystring&lt;/a&gt; 모듈과 &lt;a href=&quot;https://www.npmjs.com/package/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; 을 활용해보자.&lt;/p&gt;

&lt;h2 id=&quot;appuse&quot;&gt;app.use()&lt;/h2&gt;

&lt;p&gt;app.use 는 무엇을 하는 메소드일까? express 를 사용할 때면 이런식으로 사용했던 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
app.use(&apos;/card&apos;, (req, res, next) =&amp;gt; {
  // ...
  res.send(&apos;helloworld&apos;);
});


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/card&lt;/code&gt; 의 url 로 들어온 요청에 대해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(req, res, next) =&amp;gt; {}&lt;/code&gt; 에 해당하는 함수를 실행하는 것 같은데 그렇다면
이 함수는 무슨 함수일까?&lt;/p&gt;

&lt;h3 id=&quot;middleware-layer-router&quot;&gt;Middleware, Layer, Router&lt;/h3&gt;

&lt;p&gt;express 에서는 이런 함수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 라고 부른다. 미들웨어는 말 그대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중간에 끼어있는&lt;/code&gt; 함수로 보면 된다.&lt;/p&gt;

&lt;p&gt;Request 를 받아서, Response 를 보내기 전의 중간 처리 과정을 하는 함수를 전부 middleware 라고 부른다.&lt;/p&gt;

&lt;p&gt;그러면 express 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개발자가 middleware 를 등록해서 모든 요청마다 url 을 검사해서, url 조건을 충족하면 등록된 middleware 를 실행한다&lt;/code&gt; 의 흐름으로 진행하는구나!&lt;/p&gt;

&lt;p&gt;라고 간단하게 생각했는데 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Layer&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Router&lt;/code&gt; 의 개념이 또 등장한다.&lt;/p&gt;

&lt;p&gt;Layer 가 무엇인지 보니, middleware 를 한 번 감싸주는 계층이다.&lt;/p&gt;

&lt;p&gt;엥? Layer 로 굳이 감싸는 이유가 뭐야? 라고 생각이 들었는데 여러가지 이유가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Method, Url 검사&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;middleware 가 실행되기 전에 사용자가 등록한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/card&lt;/code&gt; url 과 들어온 Request 의 url 을 비교해야 한다.&lt;/p&gt;

&lt;p&gt;또한 특정 메소드의 요청에만 미들웨어를 실행되게 등록했다면 Method 비교도 해야할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;에러 처리&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용자가 등록한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(req, res, next) =&amp;gt; {}&lt;/code&gt; 함수에서 에러를 처리하려면, 미들웨어 안에서 try, catch 를 작성해야하는데 그렇다면 모든 미들웨어에 try, catch 가 있어야 한다.&lt;/p&gt;

&lt;p&gt;실제 express 에서는 만약 에러가 발생하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next(err)&lt;/code&gt; 의 방법으로 다음 미들웨어로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt; 를 넘긴다.
Layer 계층에서는 middleware 를 실행하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt; 가 넘어왔는지 확인하고, 넘어왔다면 에러가 발생했다고 판단해서 에러를 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;즉 Layer 계층에서 전역적으로 에러를 처리해줄 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;같은 Url, Method 에 여러 개의 미들웨어 등록&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;말 그대로 여러 개의 미들웨어가 등록된다면 이를 관리하는 계층이 필요할 수 밖에 없다.&lt;/p&gt;

&lt;h3 id=&quot;-layer-안에서-next&quot;&gt;🤔 Layer 안에서 next&lt;/h3&gt;

&lt;h3 id=&quot;-middleware-가-비동기일-경우에-에러-핸들링&quot;&gt;🤔 Middleware 가 비동기일 경우에 에러 핸들링&lt;/h3&gt;

&lt;h2 id=&quot;response-객체로-socketwrite&quot;&gt;Response 객체로 socket.write&lt;/h2&gt;

&lt;h3 id=&quot;-response-에-header-와-body-를-따로-write-하기&quot;&gt;🤔 Response 에 Header 와 Body 를 따로 write 하기&lt;/h3&gt;

&lt;h2 id=&quot;커스텀-express-를-활용해서-웹-서버-코드-작성&quot;&gt;커스텀 express 를 활용해서 웹 서버 코드 작성&lt;/h2&gt;

&lt;h3 id=&quot;만들어둔-express-를-로컬-모듈로-바꿔보자&quot;&gt;만들어둔 express 를 로컬 모듈로 바꿔보자&lt;/h3&gt;

&lt;h2 id=&quot;타입스크립트-타입을-위한-dts-만들기&quot;&gt;타입스크립트 타입을 위한 d.ts 만들기&lt;/h2&gt;

&lt;p&gt;만약 자바스크립트로 http, express 코드를 작성하고 실제 app 은 타입스크립트로 작성한다면&lt;/p&gt;

&lt;p&gt;http, express 에 타입을 명시해주는 d.ts 가 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;express-에서는-request-의-dto-를-직접-검사해줘야한다&quot;&gt;Express 에서는 Request 의 DTO 를 직접 검사해줘야한다&lt;/h3&gt;

&lt;h2 id=&quot;zod-를-활용해보자&quot;&gt;ZOD 를 활용해보자&lt;/h2&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Project&quot;]" /><category term="[&quot;Project&quot;]" /><category term="Project" /><category term="JavaScript" /><category term="TypeScript" /><summary type="html">ts/js 로 express 따라 만들기</summary></entry><entry><title type="html">Gateway, 사설망, CIDR</title><link href="https://hoex5h.github.io/Gateway,_%EC%82%AC%EC%84%A4%EB%A7%9D,_CIDR" rel="alternate" type="text/html" title="Gateway, 사설망, CIDR" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/Gateway,_%EC%82%AC%EC%84%A4%EB%A7%9D,_CIDR</id><content type="html" xml:base="https://hoex5h.github.io/Gateway,_%EC%82%AC%EC%84%A4%EB%A7%9D,_CIDR">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=kYiQGpPVnyI&quot;&gt;IP 주소를 묶는 방법, CIDR란?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;network-gateway-사설망-cidr&quot;&gt;[Network] Gateway, 사설망, CIDR&lt;/h1&gt;

&lt;h2 id=&quot;ipv4&quot;&gt;IPv4&lt;/h2&gt;

&lt;p&gt;우선 IPv4 는 총 32 비트의 숫자로 구성 되어 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;XXX.XXX.XXX.XXX 각각 8비트씩 -&amp;gt; 2^32개!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 중에서 일부 ip가 특수한 목적으로 선점되어 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사설 ip, 루프백 ip, 멀티캐스트 ip, 0.0.0.0(현 주소), 브로드캐스트 ip…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;실제로 사용할 수 있는 ip 는 2^32 보다 적다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예전에는 모든 기기에 하나씩 ip 를 할당해도 여유로웠겠지만, 기기들이 늘어난 요새는 매우 힘들다.&lt;/p&gt;

&lt;p&gt;따라서 사설망(private network)이 필요로 해졌다.&lt;/p&gt;

&lt;h2 id=&quot;사설망private-network&quot;&gt;사설망(private network)&lt;/h2&gt;

&lt;p&gt;여러대의 기기를 하나의 사설망으로 묶고, 중복되지 않도록 사설 ip를 할당해준다.&lt;/p&gt;

&lt;p&gt;이때 외부와 통신하기 위해서는 public ip 를 가지고 있는 장비가 필요한데, 이것이 Gateway 이다.&lt;/p&gt;

&lt;h2 id=&quot;gateway&quot;&gt;Gateway&lt;/h2&gt;

&lt;p&gt;게이트웨이는 다른 대역으로 라우팅을 해줄 수 있는, 주로 L3 스위치급 이상의 장비이다.&lt;/p&gt;

&lt;p&gt;가장 많이 보이는 것은 역시 어느 집에서나 볼 수 있는 공유기다. 사설망에 있는 장비들이 외부와 통신하려고 할 때, Gateway 를 거쳐서 통신하게 되는데 Gateway 는 public ip 를 하나 할당받고, NAT(Network Address Translation) 기능을 사용하여 내부 네트워크에서 오는 여러 요청을 public IP 주소를 사용하여 외부로 전송하고, 외부에서 돌아오는 응답을 올바른 내부 장치로 전달한다. 만약 사설망의 여러 장비가 같은 목적지의 같은 포트로 통신을 하려고 한다면 게이트웨이는 NAT 테이블을 활용하여 각각의 내부 소스 IP 주소와 포트 번호를 기반으로 이 요청들을 기억하고 구분한다. 외부로 나갈 때는 일반적으로 변형된 소스 포트를 사용하여, 응답이 돌아올 때 원래의 내부 IP 주소와 포트로 정확히 매핑한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들어 A 컴퓨터(192.168.0.2)가 (168.126.63.1, 443포트)에, B 컴퓨터(192.168.0.3)가 다음(168.126.63.1, 80포트)에 동시에 접근한다고 하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A와 B의 목적지 ip는 동일하지만 포트가 다르기 때문에 443포트와 80포트로 A/B 의 요청을 구분할 수 있다.


하지만 만약 A와 B 모두 443포트와 통신하려고 한다면 어떻게 될까?


443포트에서 오는 응답을 A에게 전달해야할지, B에게 전달해야할지 구분해야 하기 때문에 Gateway는 A가 보낸 요청을 4430, B가 보낸 요청을 4431 포트로 변경해서 NAT 테이블에 저장한다. 이제 게이트웨이는 4430 포트로 응답이 돌아오는지, 4431 포트로 응답이 돌아오는지에 따라 A,B 컴퓨터에 알맞게 응답을 돌려줄 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cidrclassless-inter-domain-routing&quot;&gt;CIDR(Classless Inter Domain Routing)&lt;/h2&gt;

&lt;p&gt;CIDR는 여러 개의 사설망을 구축하기 위해 망을 나누는 방법이다. 여기서 왜 Classless 라는 단어가 사용되었냐 하면, 옛날에는 A/B/C/D 클래스를 이용해서 망을 나눴기 때문이다. CIDR 을 쓰면 ABCD 클래스를 포함해서 더 다양하게 망을 나눌 수 있기 때문에 굳이 클래스라는 단어로 표기하기 않아도 되기 때문이다.&lt;/p&gt;

&lt;p&gt;CIDR의 기본적인 표기법은 192.168.0.0/24 처럼, A.B.C.D/E 와 형식이다. 그렇다면 이런 형식은 어떻게 해석할 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.0/24&lt;/code&gt; 라는 예시로 살펴보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/24&lt;/code&gt; 의 뜻은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;앞에서부터 24비트 이후에 오는 비트들을 사용할 수 있다&lt;/code&gt; 라는 뜻이다. 조금 더 풀어서 설명하자면&lt;/p&gt;

&lt;p&gt;우선 A.B.C.D 를 각각 옥텟(=8비트, 1바이트)이라고 부르며 192.168.0.0을 8비트로 변환해서 써보면,&lt;/p&gt;

&lt;p&gt;11000000.10101000.00000000.00000000 일것이다. 맨 왼쪽부터 24비트 이후에 오는 비트들을 사용할 수 있다 라는 의미는, 3번째 옥텟 이후 4번째 옥텟부터 전부 사용할 수 있다는 의미이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1번옥텟(8비트).2번옥텟(8비트).3번옥텟(8비트) «여기서부터 24비트 이후!» .4번옥텟(8비트)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 4번째 옥텟을 전부 이용하면 2^8을 전부 다 사용할 수 있다는 의미고 0~255 까지 전부 사용할 수 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.0/24 =&amp;gt; 192.168.0.0 ~ 192.168.0.255&lt;/code&gt; 까지를 나타낸 것이다.&lt;/p&gt;</content><author><name></name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Network" /><summary type="html">IP 주소를 묶는 방법, CIDR란?</summary></entry><entry><title type="html">[Kubernetes] Kubernetes CNI</title><link href="https://hoex5h.github.io/Kubernetes-_Kubernetes_CNI" rel="alternate" type="text/html" title="[Kubernetes] Kubernetes CNI" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/%5BKubernetes%5D_Kubernetes_CNI</id><content type="html" xml:base="https://hoex5h.github.io/Kubernetes-_Kubernetes_CNI">&lt;h1 id=&quot;kubernetes-kubernetes-cni&quot;&gt;[Kubernetes] Kubernetes CNI&lt;/h1&gt;

&lt;h2 id=&quot;쿠버네티스-클러스터-네트워킹의-두-가지-원칙&quot;&gt;쿠버네티스 클러스터 네트워킹의 두 가지 원칙&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/&quot;&gt;쿠버네티스의 공식 문서&lt;/a&gt;를 참조해서 CNI 가 무엇인지, 어떠한 역할을 하는지 알아보자. 참고로 한국어로 번역된 페이지도 생각보다 많으니 공식 문서에서 한국어가 지원되는 페이지인지 확인해보는 것도 좋다.&lt;/p&gt;

&lt;p&gt;쿠버네티스 클러스터의 네트워킹에서는 반드시 지켜야 하는 두 가지 원칙이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 노드에 있는 파드와, 다른 모든 노드에 있는 모든 파드들과 물리적으로 통신할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;임의의 노드에 있는 파드와, 같은 노드에 있는 모든 파드들과 물리적으로 통신할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번의 경우, 같은 노드에 있는 파드들은 같은 네임스페이스를 공유하기 때문에 로컬 호스트로 각각 컨테이너에 할당된 포트로 통신이 가능하다.&lt;/p&gt;

&lt;p&gt;같은 노드에 있는 A pod(8080) 와 B pod(7070) 은 서로 로컬호스트 포트로 통신이 가능하다는 뜻이다.&lt;/p&gt;

&lt;p&gt;그렇다면 1번 원칙은 어떻게 될까?&lt;/p&gt;

&lt;p&gt;뜬금없지만 사실 쿠버네티스 내부에는 네트워크가 구현되어 있지 않다. 위에서 언급했던 원칙처럼 어떻게 통신이 이루어져야 하는지에 대한 사양만 있고, 직접 구현되어 있지는 않다.&lt;/p&gt;

&lt;p&gt;사용자가 자신의 환경을 고려해서 적절한 네트워크 플러그인을 가져다 써야하는데, 이때 사용하는 네트워크 스펙 인터페이스가 CNI 이다.&lt;/p&gt;

&lt;h2 id=&quot;cni가-뭘까&quot;&gt;CNI가 뭘까?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/containernetworking/cni&quot;&gt;CNI Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CNI 공식 깃허브 문서에 따르면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CNI(Container Network Interface)는 리눅스 컨테이너에서 네트워크 인터페이스를 구성하기 위한 플러그인을 작성하는 사양(specification)과 라이브러리로 구성된 프로젝트이다. CNI는 오직 컨테이너간 네트워크 연결과 컨테이너가 삭제될 때, 할당된 리소스들을 지우는 것에만 관여한다. 이러한 점들 때문에, CNI는 넓은 범위의 지원을 받으며 구현하기 간단한 사양을 가지고 있다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;CNI는 리눅스 컨테이너의 네트워크 인터페이스를 관리할 수 있는 사양(specification)에 대한 프로젝트다. 컨테이너가 생성되고 삭제될 때, 네트워크 인터페이스가 생성되고 삭제되는 것을 어떻게 처리할 것인지에 대한 내용을 포함하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;cni는-그럼-왜-필요할까&quot;&gt;CNI는 그럼 왜 필요할까?&lt;/h2&gt;

&lt;p&gt;네트워크에 대한 구성은 인프라 환경에 따라서 구성이 매우 복잡하고 다양하다. 이렇게 다양한 네트워크 환경에서 수 많은 문제점들이 발생할 수 있는데, 이 수많은 문제점들에 대한 해결 방법도 천차만별이다. 결국 환경에 따라 네트워크 구성이 점점 복잡해지고 획일화되기는 쉽지 않게 될 것이다.&lt;/p&gt;

&lt;p&gt;CNI는 이렇게 네트워크 구성과 문제점이 복잡해지는 것을 막기 위해서 등장했다. 컨테이너 네트워크와 관련된 표준 스펙을 정의하고 있는 CNI를 통해서 네트워크를 구성하게 된다면 복잡했던 네트워크 구성과 문제점들을 어느정도 일축시킬 수 있을 것이다.&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-cni&quot;&gt;Kubernetes CNI&lt;/h2&gt;

&lt;p&gt;그 중에서 쿠버네티스를 위한 대표적인 플러그인들에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Calico, Flannel, Cilium ...&lt;/code&gt; 등이 있다. 더 자세한 내용은 &lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/cluster-administration/addons/#network-and-networking-policy&quot;&gt;쿠버네티스 네트워킹 애드온&lt;/a&gt; 을 참고하자.&lt;/p&gt;

&lt;h2 id=&quot;calico&quot;&gt;Calico&lt;/h2&gt;

&lt;p&gt;우리는 이번 기회에 Calico CNI 를 사용해볼 예정이기 때문에, Calico 에 대해 조금 자세히 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.tigera.io/calico/latest/about/&quot;&gt;What is Calico?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;버전이 올라가면서 Calico 공식문서 및 깃허브 링크가 바뀌는 경우가 있다. 기존의 프로젝트에서 떼어져 나온다든지, 이러한 이유들이 있는걸로 보인다.&lt;/p&gt;

&lt;h3 id=&quot;what-is-calico&quot;&gt;What is Calico&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;쿠버네티스에서는 기본적으로 파드 간 통신에 대한 기본 설정은 모두 허용(default-allow)이다. 네트워크 정책을 이용해서 이를 제한하지 않는다면, 모든 파드들은 다른 파드들과 제약없이 통신할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Calico 는 네트워크 통신을 보호하는 네트워킹과 cloud-native 의 마이크로서비스/애플리케이션을 보호하기 위한 고급 네트워크 정책으로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;Calico CNI는 containers, Kubernetes clusters, virtual machines, and native host-based workloads 를 보호하는 L3/L4 네트워킹 솔루션으로,  여러 데이터플레인을 프로그래밍하는 컨트롤 플레인이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 플레인 : 데이터 패킷이 이동하는 부분으로 실제로 사용자 또는 시스템 간에 데이터를 전송하는 역할을 담당하는 플레인. 데이터 패킷을 처리하고, 패킷의 다음 목적지로 전달하는 실질적인 처리와 전송을 담당하는 플레인 (근육)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;컨트롤 플레인 : 네트워크 경로를 결정하고, 정책을 설정하는 등의 네트워크 운영을 총괄하는 플레인. 네트워킹 장비에게 어떤 경로로 데이터 패킷을 전달해야 하는지 라우팅을 생성하고 관리하는 기능을 담당하는 플레인 (손,발)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kubernetes]_Kubernetes_CNI.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CICD&quot;]" /><category term="[&quot;CICD&quot;]" /><category term="CICD" /><category term="Kubernetes" /><summary type="html">[Kubernetes] Kubernetes CNI</summary></entry><entry><title type="html">[Kubernetes] Kubernetes Lens</title><link href="https://hoex5h.github.io/Kubernetes-_Kubernetes_Lens" rel="alternate" type="text/html" title="[Kubernetes] Kubernetes Lens" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/%5BKubernetes%5D_Kubernetes_Lens</id><content type="html" xml:base="https://hoex5h.github.io/Kubernetes-_Kubernetes_Lens">&lt;h1 id=&quot;kubernetes-kubernetes-lens&quot;&gt;[Kubernetes] Kubernetes Lens&lt;/h1&gt;

&lt;h2 id=&quot;lens-란-무엇인가&quot;&gt;Lens 란 무엇인가&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kubernetes Lens 는 클러스터 관리 GUI 툴이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쿠버네티스로 프로젝트를 할 때, 클러스터를 관리하는 것은 무조건 kubectl 만을 사용해야 하는 줄 알았다.&lt;/p&gt;

&lt;p&gt;근데 우연히 어떤 분께서 작성하신 쿠버네티스 포스트를 읽다가 Kubernetes Lens 라는걸 알게 되었는데,&lt;/p&gt;

&lt;p&gt;완전 편해보이는것이 아닌가.. 물론 CLI 도 장점이 있지만 역시 GUI가 깔끔하긴하니까..&lt;/p&gt;

&lt;h2 id=&quot;lens-설치&quot;&gt;Lens 설치&lt;/h2&gt;

&lt;p&gt;Lens 설치는 크게 어려울 것이 없다. 아래의 링크에서 운영체제에 맞게 다운로드 받으면 끝이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://k8slens.dev/&quot;&gt;Lens 공식 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;lens-에-add-cluster&quot;&gt;Lens 에 Add Cluster&lt;/h2&gt;

&lt;h3 id=&quot;vpn-&quot;&gt;VPN ?&lt;/h3&gt;

&lt;p&gt;이 부분이 사실 조금 고민거리였는데, 애초에 쿠버네티스 클러스터는 대부분 private ip 로 구성되어 있을거고&lt;/p&gt;

&lt;p&gt;내가 하고 싶은 것은 클러스터 외부에 있는 컴퓨터(내 맥북)에서 클러스터를 관리하고 싶은 것이다.&lt;/p&gt;

&lt;p&gt;그러기 위해선 내 맥북이 클러스터와 같은 네트워크로 들어가거나, 아니면 apiserver 를 외부로 노출시켜야 했다.&lt;/p&gt;

&lt;p&gt;아무래도 보안상 apiserver 를 외부로 노출시키는것 보단, vpn 을 쓰는게 좋지 않을까? 라는 생각이 들어서 iptime 공유기 vpn 설정을 따라해보려던 찰나,&lt;/p&gt;

&lt;p&gt;내가 구매했던 iptime 공유기 버전이 N104E 였는데 이건 저가형이라서 vpn 기능이 없다고 한다. vpn 해보고 싶었는데..&lt;/p&gt;

&lt;p&gt;아무튼 그러해서 apiserver 를 외부로 노출시키는 방법을 선택했다.&lt;/p&gt;

&lt;h3 id=&quot;apiserver-에-certsans-추가&quot;&gt;apiserver 에 certSANs 추가&lt;/h3&gt;

&lt;p&gt;그래서 어떤 것을 해야 하느냐?&lt;/p&gt;

&lt;p&gt;apiserver 의 CA(Certificate Authority) 에 외부 ip를 추가하는 것인데,&lt;/p&gt;

&lt;p&gt;쉽게 말해서 private 하게 구성된 apiserver 에 외부 도메인 혹은 ip 를 허용해줘야 한다.&lt;/p&gt;

&lt;p&gt;certSAN 를 추가하는 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1. kubeadm init 과 동시에 flag 로 추가하는 방법&lt;/code&gt; 이 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2. 이미 init 이 끝났다면 configMap 을 수정하는 방법&lt;/code&gt; 이 있다.&lt;/p&gt;

&lt;p&gt;kubeadm 과 동시에 flag 로 추가하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--apiserver-cert-extra-sans&lt;/code&gt; flag 와 함께 init 하면 된다.&lt;/p&gt;

&lt;p&gt;그러나 대부분 Lens 를 사용하려는 사람들은 나처럼 이미 kubeadm init 을 통해서 클러스터를 구성하고 여러 작업을 진행한 사람들일 것이다.&lt;/p&gt;

&lt;p&gt;이런 경우에는 init 을 다시하기엔 여태 해왔던 작업들이 너무 아까우니까, configmap 을 수정하고, apiserver 의 CA를 다시 발급하는 과정을 수행하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;configmap-수정&quot;&gt;Configmap 수정&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1. 현재 configmap 을 가져온다.&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ kubectl get configmap kubeadm-config -n kube-system -o jsonpath=&apos;{.data.ClusterConfiguration}&apos; &amp;gt; kubeadm-conf.yaml


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2. certSANs 를 추가한다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kubernetes]_Kubernetes_Lens.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 이미지에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;your.domain.or.ip&lt;/code&gt; 부분에 추가하고 싶은 도메인이나 ip 를 입력하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3. apiserver CA 다시 발급받기&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Cert 를 다시 발급받기 전에, 우선 기존의 Key 가 있으면 재발급이 되지 않기 때문에 기존의 key 들을 다른 곳으로 옮기거나 삭제해야한다. 혹시 잘못될 수 있으니 다른 곳으로 백업해두는 것을 권장.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ cd /etc/kubernetes/pki
$ mkdir temp
$ mv apiserver.* temp


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후, 재발급 받으면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ kubeadm init phase certs apiserver --config ~/work/kubeadm-conf.yaml


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재발급 받은 뒤에는 1번에서 만들어두었던 configmap 에 변경사항을 적용한다.&lt;/p&gt;

&lt;p&gt;{your_directory}에는 1번에서 만들어둔 configmap 의 경로.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
kubeadm init phase upload-config kubelet --config /{your_diretory}/kubeadm-conf.yaml


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;lens-에서-cluster-추가&quot;&gt;LENS 에서 cluster 추가&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kubernetes]_Kubernetes_Lens.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;공식 홈페이지에서 다운받은 뒤에, 사진처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add Cluster&lt;/code&gt; 를 눌러주면 되는데, 단순히 ~/.kube/config 파일을 불러오는게 아니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.k8slens.dev/getting-started/add-cluster/&quot;&gt;“Add_Cluster&lt;/a&gt; 이 문서를 참조하라고 하는데, 확인해보면 아래의 커맨드로 현재의 config 를 불러오면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
kubectl config view --minify --raw


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후에, 사진에서 보이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server: https://{your.ip.or.domain}:{api-server-port}&lt;/code&gt; 를 위에서 certSANs 에 추가한 도메인이나 ip로 바꿔주면 된다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kubernetes]_Kubernetes_Lens.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;잘 완료되었다면 아래와 같이 클러스터의 상황을 볼 수 있다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kubernetes]_Kubernetes_Lens.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CICD&quot;]" /><category term="[&quot;CICD&quot;]" /><category term="CICD" /><category term="Kubernetes" /><summary type="html">[Kubernetes] Kubernetes Lens</summary></entry><entry><title type="html">[Kubernetes] Metrics Server</title><link href="https://hoex5h.github.io/Kubernetes-_Metrics_Server" rel="alternate" type="text/html" title="[Kubernetes] Metrics Server" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/%5BKubernetes%5D_Metrics_Server</id><content type="html" xml:base="https://hoex5h.github.io/Kubernetes-_Metrics_Server">&lt;h1 id=&quot;kubernetes-metrics-server&quot;&gt;[Kubernetes] Metrics Server&lt;/h1&gt;

&lt;p&gt;쿠버네티스에서는 Metric 이라는 것을 활용해서 Pod 들을 오토스케일링 할 수 있다고 한다. 그렇다면 metric 은 무엇일까?&lt;/p&gt;

&lt;h2 id=&quot;metric-이-뭘까&quot;&gt;Metric 이 뭘까&lt;/h2&gt;

&lt;p&gt;metric 은 쿠버네티스에서 “어떤 시스템의 성능이나 상태” 정도로 생각하면 될 것 같다. 예를 들어 CPU 사용량, 메모리 사용량, 네트워크/디스크 입출력 등등이 있겠다.&lt;/p&gt;

&lt;h2 id=&quot;스케일링&quot;&gt;스케일링&lt;/h2&gt;

&lt;p&gt;스케일링에는 수직 스케일링과 수평 스케일링, 2가지 스케일링이 있다.&lt;/p&gt;

&lt;h3 id=&quot;수직-스케일링vertical-scaling&quot;&gt;수직 스케일링(Vertical Scaling)&lt;/h3&gt;

&lt;p&gt;수직 스케일링은 어떤 시스템의 성능(CPU, RAM 등)을 조금 더 많이 배치해서 그 시스템의 성능을 끌어 올리는 것이다.&lt;/p&gt;

&lt;p&gt;내가 사용하던 컴퓨터의 램을 16GB 에서 32GB 로 업그레이드하는 것을 수직 스케일링의 예로 들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;수평-스케일링horizontal-scaling&quot;&gt;수평 스케일링(Horizontal Scaling)&lt;/h3&gt;

&lt;p&gt;수평 스케일링은 시스템을 복제해서 여러 시스템을 배치하는 것이다. 내가 사용하던 16GB 의 컴퓨터와 동일한 사양으로 하나 더 준비해서, 컴퓨터를 총 2대 가용하는 것을 수평 스케일링의 예로 들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;hpahorizontal-pod-autoscale&quot;&gt;HPA(Horizontal Pod Autoscale)&lt;/h2&gt;

&lt;p&gt;Metric 을 이용해서 오토스케일링 한다는 것은 무엇일까? &lt;a href=&quot;https://kubernetes.io/ko/docs/tasks/run-application/horizontal-pod-autoscale/&quot;&gt;공식 문서는 여기!(kubernetes_HPA)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스에서는 필요시에 Pod 를 복제하여 수평적으로 스케일링을 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;쿠버네티스는 Horizontal Pod Autoscaling을 간헐적으로(intermittently) 실행되는 컨트롤 루프 형태로 구현했다(지속적인 프로세스가 아니다). 실행 주기는 kube-controller-manager의 –horizontal-pod-autoscaler-sync-period 파라미터에 의해 설정된다(기본 주기는 15초이다). 각 주기마다, 컨트롤러 매니저는 각 HorizontalPodAutoscaler 정의에 지정된 메트릭에 대해 리소스 사용률을 질의한다. 컨트롤러 매니저는 scaleTargetRef에 의해 정의된 타겟 리소스를 찾고 나서, 타겟 리소스의 .spec.selector 레이블을 보고 파드를 선택하며, 리소스 메트릭 API(파드 단위 리소스 메트릭 용) 또는 커스텀 메트릭 API(그 외 모든 메트릭 용)로부터 메트릭을 수집한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쿠버네티스의 컨트롤러는 일정 주기(기본 15초) 마다 타겟의 파드를 선택해서 HorizontalPodAutoscaler 정의에 지정된 메트릭을 수집한다. 만약 내가 CPU 를 지정해두었다면, 15초마다 너 지금 CPU 얼마나 쓰고 있는지 볼게~ 하고 확인하는 것이다.&lt;/p&gt;

&lt;p&gt;파드를 지정할 때, 컨테이너에 필요한 각 리소스(CPU와 메모리 등등)의 양을 선택적으로 지정할 수 있다. 예를 들어 특정 Pod에서 각각의 컨테이너가 최소 CPU 100m 은 써야하고(request), 200m 아래로 썼으면 좋겠어(limit) 라고 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;또한 HorizontalPodAutoscaler 에는 최소, 최대 레플리카의 개수를 지정할 수 있다. 예를 들어 아래와 같이 오토스케일러를 지정했다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yaml
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: web-application-hpa
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-application
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;wen-application 이라는 Deployment는 Pod가 최소 2개 있어야 하며, 최대 10개까지 복제가 가능하다.&lt;/p&gt;

&lt;p&gt;만약 존재하는 Pod 들의 평균 CPU 사용률이 50퍼센트가 넘어간다면, HPA 는 scale up 을 하게 될 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 생성된 Deployment 는 Pod 2개를 미리 생성해놓고 대기하고 있을 것이다. 이때 갑자기 많은 양의 사용자가 몰렸다고 하자.
첫 번째 Pod 의 CPU 사용률은 40퍼센트, 두 번째 Pod 의 CPU 사용률은 70퍼센트가 되었다.
15초마다 HPA는 정기적으로 CPU 사용률을 체크하다가,
“`! CPU의 평균 사용률이 (40+70)/2 = 55% 네!, 50퍼센트를 넘었잖아!” 라고 확인하게 되면
아래의 공식으로 레플리카 수를 측정해서 늘린다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원하는 레플리카 수 = ceil[현재 레플리카 수 * ( 현재 메트릭 값 / 원하는 메트릭 값 )]&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원하는 레플리카 수 = ceil[2 * (55 / 50)] = ceil(2.xx) = 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ceil 은 소숫점 올림 함수
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;현재 레플리카가 2개 존재 하기 때문에, 1개를 추가 생성해서 3개로 맞추게 된다. HPA는 이렇게 수평적으로 확장(Scale up)만 하는 것이 아니라 부하량이 줄어들고, 파드의 수가 최소 설정값 이상인 경우, HorizontalPodAutoscaler는 워크로드 리소스(디플로이먼트, 스테이트풀셋, 또는 다른 비슷한 리소스)에게 축소(Scale down)을 지시하기도 한다.&lt;/p&gt;

&lt;h2 id=&quot;metrics-server&quot;&gt;Metrics Server&lt;/h2&gt;

&lt;p&gt;그렇다면 이 Metric 은 어떻게 수집할 수 있을까? 이 역할을 바로 Metrics Server 가 담당한다. 이제 Metrics Server 를 설치해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
kubectl apply -f &amp;lt;https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml&amp;gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사실 Metrics Server 를 설치하고 CA 인증 절차를 거쳐야 하는데 지금은 간단하게 살펴만 보고 추후에 CA 인증을 하도록 하자..&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shell
kubectl edit deployment metrics-server -n kube-system


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 spec -&amp;gt; container -&amp;gt; args 항목에서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-kubelet-insecure-tls=true
를 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고!&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/configuration/manage-resources-containers/&quot;&gt;파드 및 컨테이너 리소스 관리&lt;/a&gt;&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CICD&quot;]" /><category term="[&quot;CICD&quot;]" /><category term="CICD" /><category term="Kubernetes" /><summary type="html">[Kubernetes] Metrics Server</summary></entry></feed>