<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://hoex5h.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hoex5h.github.io/" rel="alternate" type="text/html" /><updated>2025-01-23T06:27:44+00:00</updated><id>https://hoex5h.github.io/feed.xml</id><title type="html">hoeeeeeh</title><subtitle>HOEH 개발 블로그</subtitle><entry><title type="html">정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)</title><link href="https://hoex5h.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)" rel="alternate" type="text/html" title="정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)" /><published>2025-01-16T02:20:00+00:00</published><updated>2025-01-16T02:20:00+00:00</updated><id>https://hoex5h.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)</id><content type="html" xml:base="https://hoex5h.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)">&lt;p&gt;정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;다익스트라&quot;&gt;다익스트라&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;단일 시작점 최단 경로 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너비 우선 탐색과 유사&lt;/code&gt; 한 형태를 가진 알고리즘으로, 시작점에서 가까운 순서대로 정점을 방문한다. 다만 가중치(거리)가 있다보니 BFS 와 완전히 동일한 방식을 사용할 수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;우선순위-큐&quot;&gt;우선순위 큐&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐&lt;/code&gt; 를 활용한다. 우선순위 큐에 대한 자바스크립트의 구현은 &lt;a href=&quot;/우선순위_큐&quot;&gt;여기&lt;/a&gt; 를 참고하면 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(정점의 번호, 정점까지의 거리)&lt;/code&gt; 를 우선순위 큐에 넣어서 정점까지의 거리를 기준으로 우선순위 큐를 사용한다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점에서 다른 정점까지의 거리를 저장하는 배열&lt;/code&gt; 에 저장하면 된다. (간단히 dist 라고 부르자)&lt;/p&gt;

&lt;p&gt;우선순위 큐에서 최단 경로의 정점을 하나씩 꺼내면서 해당 정점과 연결된 정점들을 우선순위 큐에 넣는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;만약 v 에 아직 방문하지 않았고, 간선 (u, v) 를 검사한다고 하면 u 까지의 최단 거리에 간선 (u, v) 의 가중치를 더해서 v 까지의 거리를 구한다.&lt;/p&gt;

&lt;p&gt;만약 이 거리가 최단 거리라면 dist[v] 를 갱신하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(dist[v], v)&lt;/code&gt; 를 우선순위 큐에 다시 넣는다.&lt;/p&gt;

&lt;p&gt;여기서 주의해야할 것은 최단거리는 언제든지 갱신될 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;간선 (u, v) 를 탐색하면서 (dist[v], v) 를 우선순위 큐에 넣었는데 다른 정점을 돌면서 더 짧은 (dist[v], v) 를 우선순위 큐에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 우선순위 큐에 (dist[v], v) 가 여러 개 생길 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- 8 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 그래프에서 시작점이 A 라고 하자.  시작점을 탐색하면서 (20, D) 가 우선순위 큐에 들어가게 될 것이다.&lt;/p&gt;

&lt;p&gt;그러나 A, B, E 를 탐색하면서 (10 + 2 + 5, D) 도 우선 순위 큐에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;이 경우에 (20, D) 는 우선순위 큐에서 pop 된다고 해도 무시되어야 한다.&lt;/p&gt;

&lt;p&gt;(20, D) 가 pop 되었다는 것은 이미 이전에 (17, D) 가 pop 되었다는 것이고 dist[D] 는 17 일 것이다.&lt;/p&gt;

&lt;p&gt;따라서 dist[D] 와의 비교를 통해서 더 짧은 경로가 이전에 이미 탐색되었는지를 확인하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;증명&quot;&gt;증명&lt;/h2&gt;

&lt;p&gt;다익스트라의 증명은 귀류법(어떤 명제가 참이라고 가정한 후, 모순을 이끌어내 그 가정이 거짓임을, 즉 처음의 명제가 거짓임을 증명하는 방법) 을 통해 가능하다.&lt;/p&gt;

&lt;p&gt;여기서는 다익스트라를 통해 최단거리를 구할 수 없다고 가정하고 모순을 이끌어내려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- ? ---- B
   |             |
   ?             ?
   |             |
   D ---- ? ---- E -- ? -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 위의 그래프를 활용해서 이야기해보자.&lt;/p&gt;

&lt;p&gt;시작점 A 부터 E 까지의 거리를 구하는 것이 목표이고, 실제로는 A - D - E 가 가장 짧다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 다익스트라 알고리즘이 최단 거리를 제대로 구하지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;못한다&lt;/code&gt;고 가정하기 위해, 다익스트라 알고리즘이 A - B - E 가 가장 짧은 최단경로라는 결론을 내렸다고 가정해보자.&lt;/p&gt;

&lt;p&gt;도착점 E 에 도착한 순간, 어떤 정점은 이미 방문을 했을거고 또 어떤 정점은 우선순위 큐에 들어가 있는 상태일 수 있다.&lt;/p&gt;

&lt;p&gt;만약 D 를 방문하지 않은 상태라고 가정해보면, D 까지의 최단 거리는 dist[A] + w(A, D) 가 된다. 그런데 이미 방문한 정점 A 를 탐색하면서 D는 무조건 우선순위 큐에 (D, dist[A] + w(A, D)) 로 들어가게 되었을 것이다.&lt;/p&gt;

&lt;p&gt;A - B - E 로 진행하면서 E 또한 우선순위 큐에 들어가게 될텐데 여기서 이미 들어가있던 D 가 아닌 E 가 pop 되었다는것은 dist[E] 가 dist[D] 보다 작았기 때문이다.&lt;/p&gt;

&lt;p&gt;즉 dist[D] ≥ dist[E] 라는 소린데, 이는 D 를 거쳐서 A 에서 E 로 가는 것이 가장 짧은 경로라면 성립할 수가 없다.&lt;/p&gt;

&lt;h2 id=&quot;음수-가중치를-계산할-수-있는가&quot;&gt;음수 가중치를 계산할 수 있는가?&lt;/h2&gt;

&lt;p&gt;일반적으로 다익스트라 알고리즘은 음수 가중치가 있다면 정확한 최단 거리를 계산하지 못한다.&lt;/p&gt;

&lt;p&gt;음수 가중치가 있다는것은 이미 최단거리로 처리된 노드가 나중에 더 최단거리로 갱신될 가능성이 있다는 것이기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- -100 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다익스트라를 돌면서 E 의 최단 거리는 (10 + 2) 가 되겠지만 실제로는 10 + 2 - 100 이다.&lt;/p&gt;

&lt;p&gt;다시 말해서 이미 처리된 정점이 최단 거리라는 가정을 깨뜨릴 수 있다.&lt;/p&gt;

&lt;p&gt;만약 이미 처리된 정점이 최단 거리라는 가정을 버리고 (방문한 정점에 대한 기록을 하지 않고) 다익스트라를 작성한다면 음수 가중치를 계산할 수도 있다. 하지만, 이 경우에는 시간 복잡도가 정점의 갯수에 대해 지수함수로 증가할 수 있기 때문에 굳이 이런 식으로 다익스트라 알고리즘을 쓸 이유가 없다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;다익스트라의 시간 복잡도는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 정점마다 인접한 간선들은 모두 검사&lt;/code&gt; 하는 작업과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/code&gt; 하는 작업으로 나눌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;각-정점마다-인접한-간선들을-모두-검사&quot;&gt;각 정점마다 인접한 간선들을 모두 검사&lt;/h3&gt;

&lt;p&gt;정점의 갯수를 E, 간선의 갯수를 V 라고 할 때,&lt;/p&gt;

&lt;p&gt;각 정점마다 인접한 간선들을 모두 검사하는 작업은 정확히 모든 간선을 1번씩 검사하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(|E|)&lt;/code&gt; 의 시간이 걸리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;우선순위-큐에-원소를-넣고-삭제&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/h3&gt;

&lt;p&gt;우선순위 큐에 원소를 넣고 삭제하는 작업에서 최악의 경우에는 그래프의 모든 간선이 검사될 때마다 dist 배열이 갱신되면서 동시에 우선순위 큐에 정점의 번호가 추가되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/0.png&quot; alt=&quot;0&quot; /&gt;_다익스트라 최악의 경우 _&lt;/p&gt;

&lt;p&gt;위의 그래프에서 왼쪽의 핑크색 1번이 시작점이라고 하자.&lt;/p&gt;

&lt;p&gt;1번에서 2, 3, 4 까지의 dist 배열은 각각 6, 10, 15로 갱신되면서 우선순위 큐에 (2, 6), (10, 3), (15, 4) 로 들어갈 것이다.&lt;/p&gt;

&lt;p&gt;그러고 나서 2번 정점을 탐색하면서 dist[3] 은 6 + 3 으로 갱신되고, 우선순위 큐에 (9, 3) 이 추가 된다.&lt;/p&gt;

&lt;p&gt;이제 3번 정점을 탐색하면서 dist[4] 도 10 + 3 으로 갱신되고, 우선순위 큐에 (13, 4) 로 갱신 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;이처럼 최악의 시나리오에서는 각 간선마다 한 번씩 추가가 되고, 우선순위 큐에 원소를 추가하거나 삭제하는데 O(log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;)의 시간이 걸리고 이를 O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) 개의 원소에 대해 작업을 해야하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(|E|log|E|)&lt;/code&gt; 가 된다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;일반적인-시간-복잡도&quot;&gt;일반적인 시간 복잡도&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;위의 두 과정을 더하게 되면 O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) = O(&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) 가 되는데, 보통 그래프에서 간선의 개수 E 는 V^2 보다 작기 때문에 O(log&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;) = O(log&lt;/td&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;) 라고 볼 수 있다. 따라서 O(ElogV) 라고 할 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;경로-추적&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘을 통해 최단 거리뿐만 아니라 최단 경로를 구하려면 정점에 도착하기 직전의 정점을 기록해서 역추적을 하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;벨만-포드&quot;&gt;벨만 포드&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘과 똑같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일&lt;/code&gt; 시작점 최단 경로 알고리즘이지만, 음수 가중치가 있는 그래프에서도 최단 경로를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 음수 사이클이 있어서 최단 거리를 제대로 구하지 못하는 경우도 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;벨만포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;알고리즘-동작&quot;&gt;알고리즘 동작&lt;/h2&gt;

&lt;p&gt;시작점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, 도착점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; , dist[k] = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점부터 k 까지의 최단 거리&lt;/code&gt; , w(u, v) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;= u와 v 사이의 간선 가중치&lt;/code&gt; 라고 하자. upper[k] 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재까지 계산된&lt;/code&gt;시작점부터 k 까지의 최단 거리이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 맨 처음에는 시작점부터 시작점사이의 거리가 0이라는 것을 제외하면, 아무것도 알고 있는 것이 없다. 따라서 upper[s] = 0 으로 초기화하고 나머지는 양의 무한대 혹은 매우 큰 수로 초기화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;완화&quot;&gt;완화&lt;/h3&gt;

&lt;p&gt;이제부터 우리는 upper 배열의 값을 점차 실제 최단 거리에 가깝도록 줄여나갈 것이다. 그러려면 최단 거리의 특성을 이용해야 하는데, 아래의 특성을 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dist[v] ≤ dist[u] + w(u, v)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;dist[v] 는 v 까지 최단 거리인데, 만약 u를 거쳐서 v 로 오는 거리가 더 짧다면, u를 거쳐오는 거리가 최단 거리여야한다. 그렇기때문에 dist[v] 가 최단 거리라는 가정에 위배된다.&lt;/p&gt;

&lt;p&gt;이번에는 upper[u] + w(u, v) &amp;lt; upper[v] 인 상황을 생각해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;upper[v] 를 upper[u] + w(u, v) 로 줄이려고 하는 것이 이번 과정의 목표이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;u 까지의 최단 거리는 항상 upper[u] 보다 작거나 같을 것이다.&lt;/p&gt;

&lt;p&gt;여기서 upper[u] + w(u, v) 는 u를 거쳐 v 로 가는 경로 이므로 만약 upper[u] + w(u, v) 가 upper[v] 보다 작다는 것은, u를 거쳐서 v 로 가는 것이 현재까지 계산된 v로 가는 최단 거리보다 짧다는 것이다.&lt;/p&gt;

&lt;p&gt;즉 upper[v] 를 upper[u] + w(u, v) 로 갱신할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완화&lt;/code&gt; 라고 하고 이를 계속 수행하면서 최단거리가 되도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;완화를-얼마나-해야하는가&quot;&gt;완화를 얼마나 해야하는가?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;최단거리는 결국, 어느 한 지점까지의 최단거리에서 간선을 더한 값으로 완화되어야 한다.&lt;/p&gt;

&lt;p&gt;무슨 이야기냐 하면 시작점 s 에서 연결된 정점 a 가 있다고 하자.&lt;/p&gt;

&lt;p&gt;모든 간선을 순회하면서 한 번씩 완화를 시도했다고 하자.&lt;/p&gt;

&lt;p&gt;이때 upper[a] 는 upper[s] + w(s, a) 로 완화될 수 있다. 그런데 upper[s] 는 시작점 s 부터 s 까지의 거리이므로 당연히 0이 된다.&lt;/p&gt;

&lt;p&gt;즉, upper[a] 는 w(s, a) 로 완화될 수 있다. w(s, a) 로 완화하고 나면, 시작점 s 부터 a 까지의 가는 경로중에 w(s, a) 보다 짧은 거리가 있을 수 있을까?&lt;/p&gt;

&lt;p&gt;없다. 위의 그래프에서 s 에서 b 로 가는 최단 거리가 s → b 말고 더 있을 수는 없다.&lt;/p&gt;

&lt;p&gt;여기서 만약 s → b → c → b 가 더 짧을 수도 있지 않을까 라는 생각이 들었다면 이는 음수 사이클이다. 이 경우에는 s→ b → c → b 보다 s → b → c → b → c → b 가 더 짧고 이를 무한반복하면 당연히 더 짧아진다.&lt;/p&gt;

&lt;p&gt;음수 사이클은 기본적으로 존재하는 순간 모든 그래프에서 최단 경로라는 말을 사용할 수가 없다.&lt;/p&gt;

&lt;p&gt;이는 조금 뒤에서 더 자세히 살펴보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 전체 간선에 대한 완화를 몇 번이나 수행해야 하는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그래프를 보면 전체 간선에 대한 완화를 1회 수행하면, a와 b 까지의 최단 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;2번 수행하면 c, 3번 수행하면 d 까지의 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 s → a → b → c → d 의 모양을 가진 그래프라면 어떨까?&lt;/p&gt;

&lt;p&gt;총 4회에 거쳐 a, b, c, d 까지의 최단 거리가 완화될 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서 정점의 갯수가 V 개 일때, 아무리 많이 해도 V - 1 번이면 모든 정점들까지의 거리가 최단 거리로 완화된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;음수-사이클&quot;&gt;음수 사이클&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프를 한 번 살펴보자. A → B → C 경로를 살펴보면 A → B 는 1 이 필요한데 B → C → A 는 가중치의 합이 -3 이다. A → B → C → A 는 결국 -2 의 가중치를 갖는다.&lt;/p&gt;

&lt;p&gt;어떠한 사이클이 합이 음의 가중치를 가지는 순간, 이 사이클을 무한 반복 함으로써 가중치의 합도 음의 무한대를 가지게 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서, 정점의 개수를 V 라고 할 때, 완화가 V - 1 번 이후에도 계속 이루어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 보면 음수 사이클을 판별하는 방법은 쉽다.&lt;/p&gt;

&lt;p&gt;V - 1 번까지 완화를 진행하고 V 번째 완화를 시도해보면 된다. 만약 완화가 이루어졌다면 음수 사이클이 존재하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적-1&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;벨만 포드의 경로 추적은 다익스트라의 경로 추적과 유사하다. 다익스트라처럼 역추적을 하면 되는데,&lt;/p&gt;

&lt;p&gt;각 정점을 마지막으로 완화시킨 간선들을 토대로 역추적하면 된다. (이 간선들은 항상 최단경로의 위에 있기 때문)&lt;/p&gt;

&lt;h2 id=&quot;경로-존재-유무-판별하기&quot;&gt;경로 존재 유무 판별하기&lt;/h2&gt;

&lt;p&gt;시작점 s 에서 u 까지의 경로가 있는지 판별하는 방법은 쉽게 생각하면 upper[u] 가 Infinity 가 아니면 경로가 있다라고 착각할 수 있다.&lt;/p&gt;

&lt;p&gt;경로가 있으면 무조건 완화가 이루어질 것이라고 생각할 수 있기 때문이다. 하지만 음수 사이클이 있다면 이야기가 조금 달라진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위처럼 시작점 s 가 다른 정점들과 간선이 없다고 해도, a ↔ b 사이의 음수 사이클을 통한 완화가 이루어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 경로의 존재 유무를 판별하려면 upper[u] 가 Infinity 인지 아닌지로 판별하는 것이 아닌, 적당히 큰 값 M 에 대해서 upper[u] &amp;lt; Infinity - M 인지를 확인해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;적당히-큰-값-m&quot;&gt;적당히 큰 값 M..?&lt;/h3&gt;

&lt;p&gt;M 은 그러면 어떻게 결정할 수 있을까?&lt;/p&gt;

&lt;p&gt;우리는 위에서 완화를 최대 V - 1 번 진행한다고 했다. 그렇기 때문에 음수 사이클을 돌면서 완화된다고 했을 때, 한 번의 완화에 가장 많이 완화되는 값은 가장 작은 가중치값의 2배를 넘지 않을 것이다.&lt;/p&gt;

&lt;p&gt;위의 그래프에서는 한 번의 완화당 -1 씩 (-2 + 1) 작아진다.&lt;/p&gt;

&lt;p&gt;따라서 (가장 작은 가중치 * 2) * (V - 1) 로 M 을 설정하면 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도-1&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;벨만 포드 알고리즘은 모든 간선을 순회하는 작업을 정점의 갯수 - 1 번 만큼 진행한다. 음수 사이클을 판별하려면정점의 갯수만큼 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 O(E * V) 가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정점의 갯수 : V, 간선의 갯수 : E&lt;/p&gt;

&lt;h1 id=&quot;플로이드&quot;&gt;플로이드&lt;/h1&gt;

&lt;p&gt;다익스트라와 벨만 포드 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 시작점에서 다른 모든 정점까지의 거리&lt;/code&gt; 를 구하는 알고리즘이었다. 플로이드는 한 시작점이 아닌, 모든 정점에서 모든 정점까지의 거리를 구할 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;사실 플로이드를 굳이 안쓰고 모든 정점에서 한 번씩 다익스트라 알고리즘을 수행해도 구할 수 있다. 음수 가중치가 있다면 모든 정점에서 벨만 포드 알고리즘을 쓸 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방법보다는 더 빠르게 수행할 수 있는 알고리즘이 플로이드 와샬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;플로이드 알고리즘은 생각보다 간단하다.&lt;/p&gt;

&lt;p&gt;정점 u 에서 v 까지의 거리를 dist[u][v] 라고 정했을 때 3중 for 문을 돌면서 u → ? → v 로 갔을 때, 거리가 갱신되는지 살펴보는 것이다.&lt;/p&gt;

&lt;p&gt;그런데 플로이드 알고리즘의 프로토타입을 글로 읽고 이해하려니 꽤나 많은 생각을 거쳐야 했다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입&quot;&gt;프로토타입&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 표현식은 a 에서 출발하여 c, d 를 거쳐 b 로 가는 경로이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그래프에서 정점들의 집합을 S 라고 하고, 임의의 점을 x 라고 하자.&lt;/p&gt;

&lt;p&gt;a 에서 f 로 가는 경로에서 x 를 경유하는 것과, 경유하지 않은 것을 나누어 나타내면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기호가 너무 많아서 햇갈릴 수 있는데 a → f 의 경로는 x 를 경유해서 가는 것과 경유해서 가지 않는 것의 최소값이라는 의미일 뿐이다.&lt;/p&gt;

&lt;p&gt;여기서 이 점화식을 살짝 수정해서 더 보기 좋게 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 가지의 식을 활용해서 위의 식을 바꾸면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 된다.&lt;/p&gt;

&lt;p&gt;이제서야 우리가 자주 보던 점화식같이 생겼다.&lt;/p&gt;

&lt;p&gt;여기서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 식의 차이점에 대해서 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 식은 k 를 거치지 않고 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;반대로 위의 식은 k 까지 거쳐서 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;그런데 k 까지 가는데 k 를 거치든 안거치든 그게 다를 수 있나?&lt;/p&gt;

&lt;p&gt;도착점이 k 이므로 k를 거치는것과 안거치는것은 당연히 같다.&lt;/p&gt;

&lt;p&gt;따라서 위의 식이 같다라고 생각하게 되면 식은 더욱 간단해진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 우리가 알던 플로이드 알고리즘인, 경유점 하나를 거쳐서 가는것과 안거쳐서 가는 것 중에서 더 짧은 것을 선택하는 식이 된다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><summary type="html">정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.</summary></entry><entry><title type="html">네트워크 CS 지식</title><link href="https://hoex5h.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_CS_%EC%A7%80%EC%8B%9D" rel="alternate" type="text/html" title="네트워크 CS 지식" /><published>2025-01-15T12:26:00+00:00</published><updated>2025-01-15T12:26:00+00:00</updated><id>https://hoex5h.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_CS_%EC%A7%80%EC%8B%9D</id><content type="html" xml:base="https://hoex5h.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_CS_%EC%A7%80%EC%8B%9D">&lt;p&gt;네트워크 CS 지식 정리&lt;/p&gt;

&lt;h1 id=&quot;전이중화-통신&quot;&gt;전이중화 통신&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Full Duplex : 양쪽 장치가 동시에 송수신할 수 있는 방식&lt;/li&gt;
  &lt;li&gt;회선이 두 개(송신로, 수신로)가 있어서 같은 시간에 데이터를 주고 받을 수 있는 것이 전이중화 통신&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;반 이중화 통신은 회선 하나로 보내기 때문에 양방향으로 보내기 전에 먼저 상대방이 보냈는지 확인하는 기술 CSMA-CD&lt;/p&gt;

&lt;p&gt;충돌이 발생하면 잠깐 기다렸다가 다시 보내기&lt;/p&gt;

&lt;h1 id=&quot;무선랜&quot;&gt;무선랜&lt;/h1&gt;

&lt;p&gt;무선랜은 반이중화 통신을 사용&lt;/p&gt;

&lt;p&gt;half duplex (반이중화 통신)은 양쪽 장치가 서로 통신은 할 수 있지만 동시에는 못한다. 즉 한 번에 한 방향만 가능&lt;/p&gt;

&lt;p&gt;CSMA/CA&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용하지 않는 채널 발견&lt;/li&gt;
  &lt;li&gt;IFS 시간만큼 기다림&lt;/li&gt;
  &lt;li&gt;프레임 보내고, 다음 프레임 보내기 전까지 IFS 만큼 기다림&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대표적인 예시) 와이파이, 블루투스, 지그비&lt;/p&gt;

&lt;p&gt;2.4Ghz : 장애물에 강함, 속도가 느리다, 호환성이 좋다&lt;/p&gt;

&lt;p&gt;5Ghz : 장애물에 약함, 속도가 빠르다, 호환성이 비교적 나쁘다&lt;/p&gt;

&lt;h1 id=&quot;대규모-트래픽으로-인한-서버-과부하-해결-방법&quot;&gt;대규모 트래픽으로 인한 서버 과부하 해결 방법&lt;/h1&gt;

&lt;p&gt;서버 과부하 : 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할 때. (응답없음)&lt;/p&gt;

&lt;p&gt;자원의 한계점 도달&lt;/p&gt;

&lt;p&gt;→ 자원을 빠르게 증가시켜주기 (오토 스케일링) 클라우드 와치가 모니터링한다.&lt;/p&gt;

&lt;p&gt;→ 무료 모니터링 (netData) 도 있다.&lt;/p&gt;

&lt;p&gt;→ 쓰레스 홀드(임계치)를 정해놓고 이상으로 넘어가면 알림을 준다.&lt;/p&gt;

&lt;h2 id=&quot;모니터링을-하는-이유&quot;&gt;모니터링을 하는 이유&lt;/h2&gt;

&lt;p&gt;모니터링을 통해 어떤 서비스에 트래픽이 몰리는지, 어떤 이유로 몰리는지 분석이 가능하다.&lt;/p&gt;

&lt;p&gt;또한 페이지를 나누어 트래픽을 나눌 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;로드밸런서&quot;&gt;로드밸런서&lt;/h2&gt;

&lt;p&gt;로드밸런서를 통해서 트래픽을 분산&lt;/p&gt;

&lt;p&gt;오토 스케일링을 하는 동안 시간이 조금 걸리기 때문에, 로드 밸런스를 앞 단에 두고 트래픽을 분산 시킨다.&lt;/p&gt;

&lt;p&gt;로드 밸런서에다가도 오토 스케일링을 걸기도 한다. (트래픽이 많은 기업)&lt;/p&gt;

&lt;h2 id=&quot;블랙스완-프로토콜&quot;&gt;블랙스완 프로토콜&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;예측할 수 없는 사고가 일어난 것&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;엄청나게 많은 대비를 해도 서버가 죽을 수도 있다. 서버가 예기치 못한 사태로 죽고나서 분석은 가능하지만 미리 예측하기는 쉽지 않다.&lt;/p&gt;

&lt;p&gt;블랙스완을 대비한 규칙이 있으면 좋다.&lt;/p&gt;

&lt;p&gt;구글의 경우에는,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;영향을 받은 시스템과 각 시스템의 상대적 위험 수준을 확인&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 체계적으로 데이터를 수집하고 원인에 대한 가설을 수립한 후 이를 테스팅&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락&lt;/li&gt;
  &lt;li&gt;최대한 빨리 취약점에 영향을 받는 모든 시스템을 업데이트&lt;/li&gt;
  &lt;li&gt;복원계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;서킷-브레이커&quot;&gt;서킷 브레이커&lt;/h2&gt;

&lt;p&gt;서비스 장애를 감지하고 연쇄적으로 생기는 에러를 방지하는 기법&lt;/p&gt;

&lt;p&gt;서비스와 서비스 사이에 서킷브레이커 계층을 두고, 미리 설정해놓은 타임아웃 임계값을 넘어가면 서킷브레이커가 그 이후의 추가 호출에 무조건 에러를 반환하게 한다.&lt;/p&gt;

&lt;p&gt;다운된 서비스에 무한정 대기하면서 스레드 혹은 리소스를 잡아먹게 되면서 다른 스레드가 차단되는 현상이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기다린다&lt;/code&gt;는 것은 사용자 입장에서 썩 좋은 경험은 아니다.&lt;/p&gt;

&lt;p&gt;기다리는것보다 차라리 오류가 생겼다고 말해주는 것이 더 좋은 경험이다.&lt;/p&gt;

&lt;p&gt;따라서 빠르게 알려줄 수 있는 서킷 브레이커가 더 좋을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;서킷-브레이커의-상태&quot;&gt;서킷 브레이커의 상태&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;closed (정상) : 네트워크 요청의 실패율이 임계치보다 낮음
    &lt;ul&gt;
      &lt;li&gt;어느정도는 실패할 수 있다. 100퍼센트가 아니라 90퍼이상 성공하면 괜찮다같이 정할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;open (에러) : 에러가 임계치 이상의 상태일 때.
    &lt;ul&gt;
      &lt;li&gt;요청을 서비스로 전송하지 않고 에러를 반환. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fail test&lt;/code&gt; 라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;half open (확인 중) : 오픈 상태에서 일정 타임 아웃으로 설정된 시간이 지나면 장애가 해결되었는지 확인하기 위한 상태. 장애가 풀리면 closed 상태로, 실패하면 다시 open 상태로 전환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;서킷-브레이커의-장점&quot;&gt;서킷 브레이커의 장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;연쇄적인 에러 발생을 막아준다&lt;/li&gt;
  &lt;li&gt;일부 서비스가 다운되더라도 다른 서비스를 정상적으로 돌아가게 도와준다.&lt;/li&gt;
  &lt;li&gt;사용자 경험을 높여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Netfilix 의 Hystrix&lt;/p&gt;

&lt;h2 id=&quot;컨텐츠-관리&quot;&gt;컨텐츠 관리&lt;/h2&gt;

&lt;p&gt;어떻게 하면 서버의 부하를 덜 수 있을까&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;불필요한 컨텐츠 제거
    &lt;ul&gt;
      &lt;li&gt;인프런에서 할인 이벤트를 열었는데 장애가 발생.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://tech.inflab.com/202201-event-postmortem/&quot;&gt;https://tech.inflab.com/202201-event-postmortem/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;강의 본문을 조회하는 쿼리가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select *&lt;/code&gt; 로 되어 있어서 사용 여부와 관계 없이 모든 컬럼을 조회&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CDN 을 통한 컨텐츠 제공
    &lt;ul&gt;
      &lt;li&gt;정적 자원들은 메인 서버가 주는게 아니라, CDN 을 통해서 주면 부하가 분산된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텐츠 캐싱
    &lt;ul&gt;
      &lt;li&gt;요청 자체를 줄일 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텐츠 압축
    &lt;ul&gt;
      &lt;li&gt;텍스트 기반 리소스는 gzip / brotli 등을 통해 압축 (70퍼정도로 압축됨)&lt;/li&gt;
      &lt;li&gt;압축 푸는 서버의 자원도 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텐츠의 우아한 저하 (미리 준비된 응답)
    &lt;ul&gt;
      &lt;li&gt;시스템의 과도한 부하를 줄이기 위해 제공하는 컨텐츠 및 기능을 일시적으로 줄이는 전략
  예를 들어 정적 텍스트 페이지를 제공하거나, 검색을 비활성화하거나 더 적은 수의 검색 결과를 반환하거나, 필수적이지 않은 기능을 비활성화&lt;/li&gt;
      &lt;li&gt;이미지나 썸네일 등을 빼버리고 텍스트 기반으로 축소 서빙 (중요한 텍스트만 남기고 제거)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;https://youtu.be/xEu1bZqudE8?t=1070&quot;&gt;video&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;rest-api-란-무엇인가요&quot;&gt;REST API 란 무엇인가요?&lt;/h1&gt;

&lt;p&gt;→ Restful 한 API&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Uniform-Interface
    &lt;ol&gt;
      &lt;li&gt;API에서 자원들은 각각의 독립적인 인터페이스를 가지며, 각각의 자원들이 url 자원식별, 표현을 통한 자원조작, Self-descriptive message, HATEOAS 구조를 가지는 것을 말합니다.&lt;/li&gt;
      &lt;li&gt;독립적인 인터페이스라는 것은 서로 종속적이지 않은 인터페이스를 말합니다.
 예를 들어, 웹페이지를 변경했다고 웹 브라우저를 업데이트 하는 일은 없어야 하고, HTTP 명세나 HTML 명세가 변경되어도 웹페이지는 잘 작동해야 합니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;url-자원-식별&quot;&gt;URL 자원 식별&lt;/h3&gt;

&lt;p&gt;→ identification of resources, 자원은 url 로 식별되어야 합니다.&lt;/p&gt;

&lt;p&gt;/product/${id} 로 요청을 하면, 여기에 해당하는 product 를 줘야한다.&lt;/p&gt;

&lt;h3 id=&quot;표현을-통한-자원-조작&quot;&gt;표현을 통한 자원 조작&lt;/h3&gt;

&lt;p&gt;Manipulation of resources through representations, URL 과 GET, DELETE 등 HTTP 표준 메서드 등을 통해 자원을 조회, 삭제 등 작업을 설명할 수 있는 정보가 담겨야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getProduct 가 아니라, GET 메소드를 쓰고 /product
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;self-descriptive-messages&quot;&gt;Self-descriptive Messages&lt;/h3&gt;

&lt;p&gt;HTTP Header 에 타입을 명시하고 각 메세지들은 MIME types 에 맞춰 표현되어야 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 .json 을 반환한다면 application/json 으로 명시하기&lt;/p&gt;

&lt;h3 id=&quot;hateoas-hypermedia-as-the-engine-of-application-state&quot;&gt;HATEOAS (Hypermedia As The Engine Of Application State)&lt;/h3&gt;

&lt;p&gt;강의 내용에서 설명이 좀 부족한 것 같다.&lt;/p&gt;

&lt;p&gt;하이퍼링크에 따라 다른 페이지를 보여줘야 하며, 데이터마다 어떤 URL에서 왔는지 명시해주어야 한다.&lt;/p&gt;

&lt;p&gt;보통은 href, links, link, url 속성 중 하나에 해당 데이터의 URL 을 담아서 표기해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 상호작용 제공 : 클라이언트는 고정된 URL 경로를 하드코딩하지 않고, 서버가 제공하는 하이퍼링크를 따라가며 필요한 리소스나 작업을 탐색&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자체 설명적 메시지&lt;/strong&gt;: 서버가 응답 메시지에 포함된 링크를 통해 클라이언트가 다음 작업을 수행할 수 있는 정보를 제공합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 상태 전환&lt;/strong&gt;: 링크를 통해 리소스 상태를 바꾸거나, 새로운 리소스를 요청하거나, 작업을 수행할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HATEOAS 미적용&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;id&quot;: 123,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;email&quot;: &quot;johndoe@example.com&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HATEOAS 를 적용한 응답&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;id&quot;: 123,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;email&quot;: &quot;johndoe@example.com&quot;,
  &quot;_links&quot;: {
    &quot;self&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123&quot;
    },
    &quot;update&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123&quot;,
      &quot;method&quot;: &quot;PUT&quot;
    },
    &quot;delete&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123&quot;,
      &quot;method&quot;: &quot;DELETE&quot;
    },
    &quot;orders&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123/orders&quot;
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 응답에서는 클라이언트가 self, update, delete, orders와 같은 작업을 수행할 수 있도록 하이퍼링크를 제공합니다.
•	클라이언트는 이 링크를 활용해 데이터를 업데이트하거나 삭제하며,
•	해당 사용자가 주문한 orders 데이터를 조회할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;API 유연성 증가&lt;/strong&gt;: 클라이언트는 URL을 하드코딩할 필요 없이 동적으로 링크를 탐색하며 API와 상호작용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;버전 관리 간소화&lt;/strong&gt;: API 구조가 변경되더라도 클라이언트는 링크를 따라가기만 하면 되므로 API 변경의 영향을 덜 받습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;문서 의존성 감소&lt;/strong&gt;: API 응답 자체가 필요한 작업에 대한 정보를 포함하므로, 별도의 문서 없이도 클라이언트가 API를 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구현 복잡성&lt;/strong&gt;: 서버는 각 리소스에 적절한 하이퍼링크와 메타데이터를 제공해야 하므로 구현 난이도가 증가합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;성능 부담&lt;/strong&gt;: 추가적인 링크 정보를 포함하기 때문에 응답 크기가 커질 수 있고, 처리 시간이 늘어날 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;지원 부족&lt;/strong&gt;: 일부 클라이언트 라이브러리나 개발 환경에서 HATEOAS를 직접 활용하기 어려울 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS를 사용해야 할 때&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;•	API 사용자가 특정 리소스에서 어떤 작업을 수행할 수 있을지 동적으로 안내가 필요한 경우.&lt;/p&gt;

&lt;p&gt;•	대규모 애플리케이션에서 URL 구조가 자주 변경될 가능성이 높은 경우.&lt;/p&gt;

&lt;p&gt;•	클라이언트와 서버 간의 긴밀한 결합을 줄이고 독립성을 높이고자 할 때.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS와 RESTful API의 관계&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HATEOAS는 REST의 핵심 원칙 중 하나이지만, 모든 RESTful API가 반드시 HATEOAS를 구현해야 하는 것은 아닙니다. RESTful API 설계에서 HATEOAS의 채택 여부는 시스템의 요구 사항과 복잡성에 따라 달라질 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;stateless&quot;&gt;Stateless&lt;/h2&gt;

&lt;p&gt;REST API 를 제공하는 서버는 세션을 해당 서버 쪽에 유지하지 않는다는 의미&lt;/p&gt;

&lt;p&gt;유저의 상태가 서버에 저장되기 때문에, 세션 방식은 RESTFUL 하지 않다.&lt;/p&gt;

&lt;h2 id=&quot;cacheable&quot;&gt;Cacheable&lt;/h2&gt;

&lt;p&gt;HTTP 에선 기본값으로 캐싱이 된다.&lt;/p&gt;

&lt;h2 id=&quot;client---server-구조&quot;&gt;Client - Server 구조&lt;/h2&gt;

&lt;p&gt;클라이언트와 서버가 서로 독립적인 구조를 가져야 합니다. 물론 이는 HTTP 를 통해 가능한 구조입니다.&lt;/p&gt;

&lt;h2 id=&quot;layered-system&quot;&gt;Layered System&lt;/h2&gt;

&lt;p&gt;계층 구조로 나누어져 있는 아키텍처.&lt;/p&gt;

&lt;h2 id=&quot;rest-api-의-uri-규칙&quot;&gt;REST API 의 URI 규칙&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;동작은 HTTP 메소드로만 해야하고, url 에 해당 내용이 들어가면 안된다.
수정은 PUT, 삭제는 DELETE, 추가는 POST, 조회는 GET&lt;/li&gt;
  &lt;li&gt;확장자는 표시하면 안된다.&lt;/li&gt;
  &lt;li&gt;동사가 아닌 명사로만 표기&lt;/li&gt;
  &lt;li&gt;계층적인 내용을 담고 있어야 한다. /집/아파트/전세 처럼 내려가는 구조&lt;/li&gt;
  &lt;li&gt;대문자가 아닌 소문자만 쓰고, 너무 길 경우에는 언더바가 아닌 대시(-) 를 사용&lt;/li&gt;
  &lt;li&gt;HTTP 응답 상태코드를 활용. 성공 200, 생성 201, 리다이렉트 301 …&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그 외, api 업그레이드를 위해 Version 을 표기 (/wp/v2/posts?page=2)&lt;/p&gt;

&lt;h1 id=&quot;브라우저-렌더링-과정&quot;&gt;브라우저 렌더링 과정&lt;/h1&gt;

&lt;p&gt;아래의 과정이 동시에 일어난다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;DOM, CSSOM Tree 생성&lt;/p&gt;

    &lt;p&gt;DOM Tree : 각각의 태그 노드&lt;/p&gt;

    &lt;p&gt;CSSOM Tree : CSS 파서에 의해 정해진 스타일 규칙 적용&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOM 트리와 CSSOM 트리가 합쳐져 렌더 객체가 생성된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: none&lt;/code&gt; 이 포함된 노드는 지워지고, font-size 등 상속적인 스타일은 부모노드에만 위치하도록 설계하는 등의 최적화를 거쳐 렌더 레이어가 완성 된다.&lt;/p&gt;

&lt;p&gt;display: none 은 렌더트리에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt; 되지만, visibility: hidden 은 요소를 보이지 않게 할 뿐 여전히 레이아웃에서 공간을 차지한다.&lt;/p&gt;

&lt;p&gt;또한 렌더 레이어가 완성될 때, GPU 에서 처리되는 부분이 있으면 이 요소들은 강제적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그래픽 레이어&lt;/code&gt;로 분리된다.&lt;/p&gt;

&lt;p&gt;그래픽 레이어는 리플로우와 리페인트를 유발하지 않는다.&lt;/p&gt;

&lt;h1 id=&quot;gpt&quot;&gt;GPT&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;맞습니다. **그래픽 레이어**는 리플로우(reflow)와 리페인트(repaint)를 유발하지 않습니다. 대신 그래픽 레이어는 브라우저의 렌더링 성능 최적화와 관련이 있으며, GPU를 활용한 컴포지팅 단계에서 동작합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
	# **그래픽 레이어는 리플로우와 리페인트를 유발하지 않는다**
	
	그래픽 레이어는 브라우저의 렌더링 최적화와 관련이 있으며, GPU를 활용한 **컴포지팅(compositing)** 단계에서 동작합니다. 따라서 리플로우(Reflow)나 리페인트(Repaint)를 유발하지 않습니다.
	
	---
	
	## **리플로우와 리페인트 개념**
	
	1. **리플로우(Reflow)**  
	   - DOM의 구조나 레이아웃이 변경될 때 발생.  
	   - 예: 요소의 크기, 위치, 폰트 크기 변경 등.  
	   - **비용이 크며** 다른 요소들에게도 영향을 미칠 수 있음.
	
	2. **리페인트(Repaint)**  
	   - 레이아웃은 변경되지 않지만 요소의 스타일(예: 색상, 그림자)이 변경될 때 발생.  
	   - 리플로우보다 비용이 적지만 여전히 성능에 영향을 줄 수 있음.
	
	---
	
	## **그래픽 레이어(Graphics Layer)란?**
	
	그래픽 레이어는 브라우저가 특정 요소를 **별도의 GPU 가속 레이어로 분리**하여 관리하는 것을 의미합니다.  
	이를 통해 레이아웃 계산이나 스타일 재계산 없이 GPU에서 직접 작업(컴포지팅)을 수행합니다.
	
	### **그래픽 레이어의 특징**
	- **리플로우와 리페인트를 유발하지 않음.**
	- GPU에서 병렬로 작업을 처리하여 성능을 향상시킴.
	- 독립적인 레이어로 분리되어 다른 레이어와 병렬로 처리 가능.
	
	---
	
	## **그래픽 레이어가 생성되는 상황**
	
	1. **CSS 속성**:
	   - `transform` (예: `translate`, `scale`, `rotate` 등)
	   - `opacity`
	   - `will-change` (예: `will-change: transform, opacity;`)
	   - `filter`
	
	2. **CSS 애니메이션 또는 트랜지션**:
	   - GPU 가속이 필요한 속성(`transform`, `opacity` 등)에 대한 애니메이션.
	
	3. **하드웨어 가속 사용**:
	   - 예: `translate3d` 또는 `translateZ` 사용 시.
	
	---
	
	## **그래픽 레이어의 장점**
	
	1. **성능 최적화**:
	   - 레이아웃 계산과 페인트 작업의 부하를 줄임.
	   - GPU에서 병렬적으로 작업을 처리해 성능을 크게 개선.
	
	2. **애니메이션 부드러움**:
	   - GPU 가속을 활용해 애니메이션을 부드럽게 렌더링.
	   - 리플로우와 리페인트를 유발하지 않음.
	
	---
	
	## **예시**
	
	### **리플로우/리페인트를 유발하는 경우**
	css
	.element {
	  width: 100px;
	  height: 100px;
	  background-color: red;
	  transition: width 1s;
	}
	
		•	width 속성은 레이아웃을 변경하므로 리플로우가 발생.
	
	그래픽 레이어를 활용한 경우
	.element {
	  width: 100px;
	  height: 100px;
	  background-color: red;
	  transform: translateX(0);
	  transition: transform 1s;
	}
		•	transform 속성은 레이아웃을 변경하지 않으므로 리플로우나 리페인트를 유발하지 않음.
		•	GPU에서 작업이 처리되어 성능이 더 부드럽고 빠름.
		
		그래픽 레이어는 GPU 가속을 활용한 컴포지팅 단계에서 처리되므로 리플로우와 리페인트를 유발하지 않습니다.
	성능 최적화가 필요한 애니메이션이나 트랜지션에서는 그래픽 레이어를 적극적으로 활용하는 것이 좋습니다.
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;레이아웃 잡기 (Layout)&lt;/li&gt;
  &lt;li&gt;렌더레이어를 대상으로 칠하기 (Paint)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레이어 합치기 (Composite Layer) 및 표기&lt;/p&gt;

    &lt;p&gt;각각의 레이어로부터 비트맵이 생성되고, GPU에 텍스쳐로 업로드 됩니다. 그 다음 텍스쳐들은 서로 합쳐져 하나의 이미지로 렌더링되며 화면으로 출력됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 렌더트리와 DOM 트리는 1:1 대응일까요?&lt;br /&gt;
아닙니다. DOM 트리 &amp;gt; 렌더 객체 &amp;gt; 렌더 트리가 되는 과정에서 display: none 으로 사라지는 렌더 객체들이 있을 수 있기 때문.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;아닙니다. DOM 트리 &amp;gt; 렌더 객체 &amp;gt; 렌더 트리가 되는 과정에서 display: none 으로 사라지는 렌더 객체들이 있을 수 있기 때문.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;wwwnavercom-을-주소창에-입력했을-때-생기는-과정-그리고-dns-까지-설명해주세요&quot;&gt;&lt;a href=&quot;http://www.naver.com/&quot;&gt;www.naver.com&lt;/a&gt; 을 주소창에 입력했을 때 생기는 과정, 그리고 DNS 까지 설명해주세요&lt;/h1&gt;

&lt;details&gt;
&lt;summary&gt;강의 답변&lt;/summary&gt;

리다이렉트, 캐싱, DNS, IP 라우팅, TCP 연결 구축을 거쳐


요청, 응답이 일어나는 TTFB(TIme TO First Byte) 가 시작되고


이후 컨텐츠를 다운받게 되고,


브라우저 렌더링 과정을 거쳐 네이버라는 화면이 나타나게 됩니다.


&lt;/details&gt;

&lt;h2 id=&quot;리다이렉트&quot;&gt;리다이렉트&lt;/h2&gt;

&lt;p&gt;리다이렉트가 있다면 리다이렉트를 진행하고, 없다면 그대로 해당 요청에 대한 과정이 진행&lt;/p&gt;

&lt;h2 id=&quot;캐싱&quot;&gt;캐싱&lt;/h2&gt;

&lt;p&gt;해당 요청이 캐싱이 가능한지, 가능하지 않은지를 파악합니다. 캐싱이 이미 된 요청이라면 캐싱된 값을 반환하며, 캐싱이 되지 않은 새로운 요청이라면 그 다음 단계로 넘어갑니다.&lt;/p&gt;

&lt;p&gt;캐싱은 요청된 값의 결과값을 저장하고 그 값을 다시 요청하면 다시 제공하는 기술입니다.&lt;/p&gt;

&lt;p&gt;브라우저 캐시와, 공유 캐시로 나뉘어집니다.&lt;/p&gt;

&lt;h3 id=&quot;브라우저-캐시&quot;&gt;브라우저 캐시&lt;/h3&gt;

&lt;p&gt;쿠키, 로컬스토리지 등을 포함한 캐시 (개인, private 캐시)&lt;/p&gt;

&lt;h3 id=&quot;공유-캐시&quot;&gt;공유 캐시&lt;/h3&gt;

&lt;p&gt;클라이언트와 서버 사이에 있으며, 사용자간에 공유할 수 있는 응답을 저장할 수 있다. 예를 들어, 요청한 서버 앞 단에 프록시 서버가 캐싱을 하고 있는 것. 이를 리버스 프록시를 둬서 내부 서버로 포워드한다고도 말합니다.&lt;/p&gt;

&lt;h2 id=&quot;dns&quot;&gt;DNS&lt;/h2&gt;

&lt;p&gt;Domain Name System 은 계층적인 도메인 구조와 분산된 데이터베이스를 이용한 시스템으로,&lt;/p&gt;

&lt;p&gt;FQDN 을 인터넷 프로토콜인 IP 로 바꿔주는 시스템입니다.&lt;/p&gt;

&lt;p&gt;이는 DNS 관련 요청을 네임서버로 전달하고, 해당 응답값을 클라이언트에게 전달하는 Resolver,&lt;/p&gt;

&lt;p&gt;도메인을 IP 로 변환하는 네임서버 등으로 이루어져있습니다.&lt;/p&gt;

&lt;h3 id=&quot;fqdn&quot;&gt;FQDN&lt;/h3&gt;

&lt;p&gt;FQDN (Fully Qualified Domain Name) 은 호스트와 도메인이 합쳐진 완전한 도메인 이름을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.naver.com/&quot;&gt;www.naver.com&lt;/a&gt; 에서 www 등은 호스트 부분 혹은 서브 도메인, naver.com 은 도메인이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;dns-캐싱&quot;&gt;DNS 캐싱&lt;/h3&gt;

&lt;p&gt;미리 해당 도메인 이름을 요청한 적이 있다면, 로컬 PC 에 자동적으로 저장됩니다.&lt;/p&gt;

&lt;p&gt;브라우저 캐싱과, OS 캐싱이 있습니다.&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;gpt&lt;/summary&gt;


```
text
# **DNS 캐싱**

DNS 캐싱은 도메인 이름을 요청할 때 발생하는 네트워크 트래픽을 줄이고, 더 빠른 응답 속도를 제공하기 위해 이전에 조회한 도메인 이름과 IP 주소를 **로컬에 저장**하는 기술입니다.  
- 즉, 이미 요청한 도메인 이름이 있다면, DNS 서버에 다시 요청하지 않고 **캐싱된 데이터**를 사용합니다.

---

## **DNS 캐싱의 종류**

DNS 캐시는 **다양한 계층**에서 발생할 수 있습니다. 주요 캐싱 계층은 다음과 같습니다:

### 1. **브라우저 캐싱**
- **웹 브라우저**는 자체적으로 DNS 캐시를 관리합니다.
- 동일한 도메인 이름을 여러 번 요청하는 경우, 브라우저 캐시에서 IP 주소를 가져와 빠르게 처리합니다.
- 브라우저별로 DNS 캐싱 시간(TTL, Time to Live)이 다를 수 있습니다.
  - 예: Chrome, Firefox 등에서 TTL 설정에 따라 캐시가 유지됩니다.

#### **브라우저 DNS 캐시 확인 및 삭제**
- Chrome: `chrome://net-internals/#dns`로 접속하여 캐시를 확인하거나 삭제할 수 있음.

---

### 2. **OS 캐싱**
- 운영체제(Windows, macOS, Linux)는 **DNS Resolver Cache**라는 이름으로 자체적인 DNS 캐시를 관리합니다.
- 애플리케이션(예: 브라우저)에서 DNS 조회 요청이 들어오면, DNS 서버에 요청하기 전에 **운영체제의 캐시**를 먼저 확인합니다.

#### **OS DNS 캐시 확인 및 삭제 방법**
- **Windows**: 
  - 확인: 명령 프롬프트에서 `ipconfig /displaydns`
  - 삭제: 명령 프롬프트에서 `ipconfig /flushdns`
- **macOS**: 
  - 삭제: `sudo dscacheutil -flushcache &amp;amp;&amp;amp; sudo killall -HUP mDNSResponder`
- **Linux**: 
  - 삭제: `sudo systemd-resolve --flush-caches` (시스템에 따라 명령어가 다를 수 있음)

---

## **DNS 캐싱의 장점**

1. **빠른 응답 속도**:
   - 캐시된 데이터를 사용하여 DNS 서버와의 통신 시간을 줄임.
2. **네트워크 트래픽 감소**:
   - DNS 요청이 줄어들어 네트워크 대역폭을 절약.
3. **서버 부하 감소**:
   - DNS 서버로의 요청 수가 줄어들어 서버 부하를 완화.

---

## **DNS 캐싱의 단점**

1. **오래된 정보**:
   - TTL(Time to Live)이 만료되지 않은 경우, IP 주소가 변경되었더라도 **오래된 캐시 데이터를 사용할 수 있음**.
   - 이로 인해 사용자가 변경된 서버에 접속하지 못하거나 오류가 발생할 수 있음.
2. **캐시 초기화 필요**:
   - DNS 관련 문제를 해결하려면 브라우저, OS, 네트워크 장치의 캐시를 수동으로 초기화해야 할 때가 있음.

---

## **TTL(Time to Live)**
- DNS 캐시는 **TTL(Time to Live)** 값을 기반으로 유지됩니다.
- TTL은 DNS 응답에 포함된 값으로, 특정 도메인-IP 매핑이 캐시에서 얼마나 오래 유지될지를 정의합니다.
- TTL이 만료되면, 캐시된 데이터는 삭제되고 새 데이터를 DNS 서버에서 요청하게 됩니다.

---

## **정리**

DNS 캐싱은 **브라우저 캐싱**과 **OS 캐싱**의 두 가지 주요 계층에서 이루어지며, 인터넷 속도를 향상시키고 서버 부하를 줄이는 데 큰 역할을 합니다.  
문제가 발생했을 때는 캐시를 수동으로 초기화하거나 TTL 설정을 확인해 문제를 해결할 수 있습니다.

```



&lt;/details&gt;

&lt;h2 id=&quot;ip-라우팅&quot;&gt;IP 라우팅&lt;/h2&gt;

&lt;p&gt;해당 IP 를 기반으로 라우팅, ARP 과정을 거쳐 실제 서버를 찾습니다.&lt;/p&gt;

&lt;h2 id=&quot;tcp-연결-구축-http--20&quot;&gt;TCP 연결 구축 (HTTP  ~2.0)&lt;/h2&gt;

&lt;p&gt;브라우저가 TCP 3Way handshake 및 SSL 연결 등을 통해 연결을 설정합니다.&lt;/p&gt;

&lt;p&gt;이후에 요청을 보냄으로써 서버로부터 응답을 받습니다.&lt;/p&gt;

&lt;h2 id=&quot;quic-연결-http-30&quot;&gt;QUIC 연결 (HTTP 3.0)&lt;/h2&gt;

&lt;h2 id=&quot;컨텐츠-다운로드&quot;&gt;컨텐츠 다운로드&lt;/h2&gt;

&lt;p&gt;요청한 컨텐츠를 서버로부터 다운 받습니다.&lt;/p&gt;

&lt;p&gt;처음 다운로드를 시작할 때, TTFB (Time To First Byte) 라고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;브라우저-렌더링&quot;&gt;브라우저 렌더링&lt;/h2&gt;

&lt;p&gt;받은 데이터를 바탕으로 브라우저 엔진이 브라우저 렌더링 과정을 거쳐 화면을 만듭니다.&lt;/p&gt;

&lt;h1 id=&quot;이더넷-프레임은-무엇이며-구조가-어떻게-되나요&quot;&gt;이더넷 프레임은 무엇이며, 구조가 어떻게 되나요?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이더넷프레임이란 데이터 링크계층의 데이터 단위이며 이더넷 프레임을 기반으로 데이터가 전달 되며 다음과 같은 필드로 구성되어있습니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**Preamble**&lt;/u&gt; : [7바이트]
이더넷 프레임이 시작임을 알려준다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**SFD**&lt;/u&gt; : [1바이트]
Start frame delimiter, 다음 필드부터 주소필드가 시작됨을 알려줍니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**Address**&lt;/u&gt; : [6, 6바이트]
목적지 주소, 시작지 주소입니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**EtherType**&lt;/u&gt; : [2바이트]
데이터링크계층 위의 IP 프로토콜을 정의합니다. (IPv4, Ipv6)&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**Payload**&lt;/u&gt; : [가변바이트]
데이터 또는 페이로드라고 합니다. 가변길이 필드입니다. 해당 필드는 이진데이터(0과1로 이루어진 데이터)로 구성됩니다. IEEE 표준은 최대 페이로드를 1500 바이 트로 지정하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**FCS**&lt;/u&gt; : [4바이트]
frame check sequence이며 수신측의 에러검출을 위해 삽입하는 필드입니 다. CRC 에러검출 기법에 의해 생성된 비트배열이 여기에 담깁니다. 비트배열을 기반으로 수신된 데이터가 손상되었는지를 확인하고, 에러 확인 시에는 해당 프레임을 폐기하고 송신측에 재전송을 요구하기 위한 필드입니다.
CRC 알고리즘에 의해 만들어진 비트 배열이 담기는 필드&lt;/p&gt;

&lt;h1 id=&quot;cors란-무엇인가요&quot;&gt;CORS란 무엇인가요?&lt;/h1&gt;

&lt;h2 id=&quot;origin&quot;&gt;Origin&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오리진&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로토콜 + 호스트네임 + 포트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;a href=&quot;https://shopping.naver.com/home&quot;&gt;https://shopping.naver.com/home&lt;/a&gt; 에서&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https&lt;/code&gt; , &lt;a href=&quot;http://shopping.naver.com/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shopping.naver.com&lt;/code&gt;&lt;/a&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8080&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;sop-same-origin-policy&quot;&gt;SOP (Same Origin Policy)&lt;/h2&gt;

&lt;p&gt;브라우저 상에서 오로지 같은 오리진끼리만 요청을 허가하는 보안 정책.&lt;/p&gt;

&lt;p&gt;브라우저 상에서 다른 오리진끼리는 통신이 불가능하다.&lt;/p&gt;

&lt;p&gt;다른 오리진에서 요청을 하는 공격에 방지하기 위함&lt;/p&gt;

&lt;h2 id=&quot;cors-cross-origin-resource-sharing&quot;&gt;CORS (Cross Origin Resource Sharing)&lt;/h2&gt;

&lt;p&gt;다른 오리진과 통신을 해야하는 일이 있을 수 있기 때문에, SOP 보다 조금 느슨한 규칙&lt;/p&gt;

&lt;p&gt;포트번호만 달라도 오리진이 다르기 때문에 개발 과정에서 백/프 끼리도 보통 오리진이 다르다&lt;/p&gt;

&lt;p&gt;HTTP 헤더를 기반으로 브라우저가 다른 오리진에 대한 리소스(image, css, js, video 등) 로드를 허용할지 말지에 대한 규칙&lt;/p&gt;

&lt;h2 id=&quot;preflight-request-simple-request&quot;&gt;Preflight Request, Simple Request&lt;/h2&gt;

&lt;p&gt;CORS는 브라우저가 다른 출처(origin)의 리소스에 접근할 때 안전을 보장하기 위해 사용하는 메커니즘입니다. 요청은 크게 두 가지로 나뉩니다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-simple-request-단순-요청&quot;&gt;1. &lt;strong&gt;Simple Request (단순 요청)&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저가 사전 확인(preflight)을 생략하고 &lt;strong&gt;직접 요청&lt;/strong&gt;을 서버에 보내는 요청입니다.&lt;/li&gt;
  &lt;li&gt;CORS 규칙에서 &lt;strong&gt;Simple Request&lt;/strong&gt;는 특정 조건을 만족해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;simple-request의-조건&quot;&gt;Simple Request의 조건&lt;/h3&gt;

&lt;p&gt;Simple Request가 되기 위해서는 아래 조건을 모두 충족해야 합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;HTTP 메서드&lt;/strong&gt;가 다음 중 하나여야 합니다:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;헤더(Header)&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;요청에 사용된 헤더가 CORS에서 허용된 &lt;strong&gt;간단한 헤더(Simple Headers)&lt;/strong&gt;만 포함해야 합니다.&lt;/li&gt;
      &lt;li&gt;허용된 간단한 헤더:
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept-Language&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Language&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; (단, 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;, 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt;일 경우만 허용)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Content-Type&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;요청 본문(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;)의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; 값이 아래 중 하나여야 합니다:
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Credentials&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;요청에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Authorization&lt;/code&gt; 헤더나 쿠키와 같은 자격 증명(크리덴셜)이 포함되지 않아야 함 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withCredentials&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;동작-방식&quot;&gt;동작 방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저는 요청을 바로 서버에 보냅니다.&lt;/li&gt;
  &lt;li&gt;서버는 요청의 출처(origin)와 헤더를 보고 허용 여부를 판단합니다.&lt;/li&gt;
  &lt;li&gt;서버가 허용하면 브라우저는 응답을 처리합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-preflight-request-사전-요청&quot;&gt;2. &lt;strong&gt;Preflight Request (사전 요청)&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;요청이 Simple Request 조건을 충족하지 않으면 브라우저는 &lt;strong&gt;Preflight Request&lt;/strong&gt;를 먼저 보냅니다.&lt;/li&gt;
  &lt;li&gt;Preflight Request는 실제 요청 전에 서버가 해당 요청을 허용할지 여부를 확인하는 &lt;strong&gt;안전성 검사&lt;/strong&gt;입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;preflight-request의-동작&quot;&gt;Preflight Request의 동작&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;브라우저는 &lt;strong&gt;HTTP OPTIONS&lt;/strong&gt; 메서드로 사전 요청을 보냅니다.&lt;/li&gt;
  &lt;li&gt;Preflight Request에는 아래와 같은 정보를 포함합니다:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Origin&lt;/code&gt;: 요청의 출처.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Request-Method&lt;/code&gt;: 실제 요청에 사용될 HTTP 메서드.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Request-Headers&lt;/code&gt;: 실제 요청에서 사용될 커스텀 헤더(있을 경우).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 Preflight Request에 대해 응답합니다:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Origin&lt;/code&gt;: 허용된 출처.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Methods&lt;/code&gt;: 허용된 HTTP 메서드.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Headers&lt;/code&gt;: 허용된 커스텀 헤더.&lt;/li&gt;
      &lt;li&gt;응답 상태 코드가 200이면 브라우저는 실제 요청을 보냅니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;preflight가-필요한-조건&quot;&gt;Preflight가 필요한 조건&lt;/h3&gt;

&lt;p&gt;Preflight Request는 다음 중 하나 이상에 해당할 때 발생합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;요청 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;가 아닌 경우 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATCH&lt;/code&gt; 등).&lt;/li&gt;
  &lt;li&gt;요청 헤더가 &lt;strong&gt;간단한 헤더&lt;/strong&gt; 외의 커스텀 헤더를 포함하는 경우.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt;이 아닌 경우 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/json&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;요청에 자격 증명(크리덴셜, 예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Authorization&lt;/code&gt; 헤더나 쿠키)이 포함된 경우.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;네이글-알고리즘이란-무엇인가요&quot;&gt;네이글 알고리즘이란 무엇인가요?&lt;/h1&gt;

&lt;p&gt;네이글 알고리즘은 네트워크의 효율성을 높이기 위해 네트워크를 통해 전송되어야 하는 패킷의 수를 줄이고 적은 양의 데이터를 자주 보내면 발생되는 대역폭 낭비를 막아주는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기존 방법과 다르게 패킷을 보낼 때 고정 크기의 버퍼에 모아두고 버퍼에 어느정도 차면 그 때 보내고, 다시 ACK 가 오면 버퍼에 찬 데이터를 보내는 방법&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;네이글-알고리즘의-장점&quot;&gt;네이글 알고리즘의 장점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;전송하는 패킷의 수가 줄어들기 때문에 네트워크의 혼잡도를 줄이고 패킷 손실률을 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;작은 패킷들을 많이 전송할 때, 각 패킷에 포함된 헤더의 크기가 커져서 대역폭 소모가 많이 발생할 수 있다. 패킷의 수를 줄임으로써 이러한 오버헤드를 줄일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;네이글-알고리즘의-단점&quot;&gt;네이글 알고리즘의 단점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;작은 패킷의 수를 줄이기 위해 데이터를 버퍼링하고, 충분한 양의 데이터가 모일 때 까지 패킷 전송을 지연시킨다.&lt;/li&gt;
  &lt;li&gt;ACK를 받기 전까지 데이터를 전송하지 않기 때문에 지연시간이 발생할 수 있다.
(실시간이 중요하다면 사용하기 힘들다)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;http-의-멱등성에-대해-설명해주세요&quot;&gt;HTTP 의 멱등성에 대해 설명해주세요&lt;/h1&gt;

&lt;p&gt;HTTP 멱등성(idempotent)이란 하나의 요청이 아닌 여러번 동일한 요청을 보냈을 때 서버가 같은 상태를 가지는 것을 멱등성이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.tosspayments.com/blog/what-is-idempotency&quot;&gt;https://docs.tosspayments.com/blog/what-is-idempotency&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;멱등성을-가지는-메소드&quot;&gt;멱등성을 가지는 메소드&lt;/h2&gt;

&lt;h3 id=&quot;get-안전한-메소드&quot;&gt;GET (안전한 메소드)&lt;/h3&gt;

&lt;p&gt;서버에서 정보를 가져오는 것을 여러 번 해도, 동일한 정보를 가져온다.&lt;/p&gt;

&lt;h3 id=&quot;head-안전한-메소드&quot;&gt;HEAD (안전한 메소드)&lt;/h3&gt;

&lt;p&gt;헤드는 GET 요청이 생성하는 응답의 헤더를 검색하는데 사용됩니다.&lt;/p&gt;

&lt;p&gt;따라서 서버의 상태를 변경하지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;options-안전한-메소드&quot;&gt;OPTIONS (안전한 메소드)&lt;/h3&gt;

&lt;p&gt;대상 리소스의 통신 옵션 ( 서버에서 지원하는 HTTP 메서드 등)을 가져올 때 사용&lt;/p&gt;

&lt;h3 id=&quot;put-안전한-메소드는-아님&quot;&gt;PUT (안전한 메소드는 아님)&lt;/h3&gt;

&lt;p&gt;서버에 있는 데이터를 아예 교체하기 때문에 여러 번 보내도 똑같은 데이터로 교체될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;delete-안전한-메소드는-아님&quot;&gt;DELETE (안전한 메소드는 아님)&lt;/h3&gt;

&lt;p&gt;삭제 작업을 반복해도 시스템 상태가 더 이상 변경되지 않습니다.&lt;/p&gt;

&lt;p&gt;그런데 흠..&lt;/p&gt;

&lt;p&gt;예를 들어 DELETE /post/lastest 라고 해보자. 가장 최신 포스트를 지우게 된다고 하면 서버의 상태가 바뀌지 않나?&lt;/p&gt;

&lt;p&gt;또한 만약 DELETE /post/abc 인 상황에서 abc 라는 리소스가 여러 개라면? DELETE 는 abc 리소스를 하나만 지우는 상황이라면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;이러면 또 멱등성을 보장할 수 없는게 아닌가?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;는 멱등성&lt;/strong&gt;을 보장하는 메서드이지만, &lt;strong&gt;대상 리소스를 정확히 지정해야&lt;/strong&gt; 합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE /posts/123&lt;/code&gt;와 같이 &lt;strong&gt;구체적인 리소스&lt;/strong&gt;를 명시해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE /posts/last&lt;/code&gt;와 같이 마지막 게시글을 삭제하는 요청은 &lt;strong&gt;상태 변화가 계속 일어나므로 멱등성을 가지지 않&lt;/strong&gt;습니다.&lt;/li&gt;
  &lt;li&gt;이런 경우에는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;를 사용하는 것이 더 적절&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;요약&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;는 멱등성을 보장하므로 &lt;strong&gt;상태 변화가 없을 때&lt;/strong&gt; 사용해야 합니다. 상태가 계속 바뀌는 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;를 사용하는 것이 HTTP 스펙상 더 맞습니다.&lt;/p&gt;

&lt;h3 id=&quot;post&quot;&gt;POST&lt;/h3&gt;

&lt;p&gt;서버에 동일한 요청을 여러 번 보내면, 보낸 만큼 생성 될 것이기 때문에 서버의 상태가 바뀌게 된다.&lt;/p&gt;

&lt;h3 id=&quot;patch&quot;&gt;PATCH&lt;/h3&gt;

&lt;p&gt;리소스를 부분적으로 업데이트 하게 되는데, 멱등성의 여부는 PATCH 를 실행하는 방법에 따라 달라진다.&lt;/p&gt;

&lt;p&gt;예를 들어 특정 부분을 새롭게 교체하는거라면 멱등성을 가지지만, 하나씩 증가하거나 빼기, 배열에 요소 추가 등의 방식은 멱등성을 가지지 않는다.&lt;/p&gt;

&lt;p&gt;함수형 프로그래밍이 생각나네&lt;/p&gt;

&lt;h2 id=&quot;http-멱등성을-고려한-api-설계&quot;&gt;HTTP 멱등성을 고려한 API 설계&lt;/h2&gt;

&lt;p&gt;POST 메서드의 경우 idempotency Key를 보내서 동일한 요청인지를 식별하게 합니다.
이를 통해 동일한 작업의 재시도를 인식하고 한 번만 처리되도록 합니다. 이는 중복 트랜잭션을 피해야 하는 결제 처리 API에서 자주 사용됩니다.&lt;/p&gt;

&lt;details&gt;
&lt;summary&gt;Idempotency Key&lt;/summary&gt;


```
text

Idempotency Key는 중복 요청을 방지하고 멱등성을 보장하는 데 중요한 역할을 하는 기법입니다. 특히 POST 메서드에서는 요청을 여러 번 보내면 여러 번 처리가 발생하는 경우가 많기 때문에, 이를 방지하기 위해 Idempotency Key를 사용합니다.

1. Idempotency Key의 개념
Idempotency Key는 클라이언트가 서버에 보내는 고유한 값으로, 동일한 작업을 여러 번 요청하더라도 서버에서 해당 작업을 한 번만 처리하도록 보장하는 키입니다. 이는 멱등성을 보장하기 위한 기술로, 중복 트랜잭션이나 중복 작업이 발생하지 않도록 합니다.

Idempotency Key는 클라이언트가 POST 요청을 보낼 때마다 함께 전송합니다.
이 키는 요청이 중복되었는지 여부를 서버가 인식할 수 있게 해줍니다.
2. POST 메서드와 멱등성
일반적으로 POST 메서드는 리소스를 생성하거나 데이터를 변경하는 요청에 사용됩니다. 이런 요청은 여러 번 실행될 경우 여러 번 처리되거나 중복된 리소스가 생성될 수 있습니다. 예를 들어:

사용자가 결제를 시도하는 경우, 결제 요청을 여러 번 보내면 여러 번 결제가 처리될 위험이 있습니다.
서버가 POST 요청을 여러 번 받아들여 중복된 리소스를 생성하거나 트랜잭션을 두 번 처리할 수 있습니다.
3. Idempotency Key의 역할
Idempotency Key는 이러한 중복 처리를 피하기 위한 방법으로 사용됩니다. 서버는 동일한 Idempotency Key를 가진 요청이 들어오면, 이미 처리한 작업을 다시 처리하지 않고 응답을 재사용합니다.

예시: 결제 처리 API
결제 처리 API에서 Idempotency Key가 어떻게 동작하는지 살펴봅시다:

클라이언트가 결제 요청을 보냄:

클라이언트는 결제 요청과 함께 고유한 Idempotency Key를 생성하고 보냅니다.
예: POST /payment 요청과 함께 { &quot;idempotencyKey&quot;: &quot;12345&quot; }를 보냄.
서버는 Idempotency Key를 확인:

서버는 요청을 처리하기 전에 이 Idempotency Key가 이전에 처리된 적이 있는지 확인합니다.
만약 이 키가 이미 처리된 적이 있다면, 서버는 새로운 결제를 생성하지 않고, 이전 응답을 그대로 재사용합니다.
만약 이 키가 처리되지 않은 키라면, 서버는 결제를 처리하고 새로운 결제 결과와 함께 Idempotency Key를 저장합니다.
동일한 요청이 여러 번 들어오면:

두 번째 요청에서 동일한 Idempotency Key가 포함되면, 서버는 이미 처리된 요청으로 인식하고, 같은 결과를 반환합니다.
이로써 중복 결제나 트랜잭션이 발생하지 않게 됩니다.
4. Idempotency Key가 필요한 이유
네트워크 불안정성:

클라이언트가 네트워크 문제로 요청이 실패했다고 생각하고 요청을 다시 보낼 수 있습니다. 그러나 실제로 첫 번째 요청은 서버에서 성공적으로 처리되었을 수 있습니다.
Idempotency Key는 서버가 이 중복 요청을 인식하고, 두 번째 요청에서 이전의 결과를 반환함으로써 중복 처리를 방지합니다.
중복 트랜잭션 방지:

결제나 주문 처리 등과 같은 중요한 작업에서는 동일한 트랜잭션이 두 번 이상 처리되면 큰 문제가 될 수 있습니다.
Idempotency Key는 이러한 중복 트랜잭션을 피하기 위해 사용됩니다.
시스템의 안정성 증가:

여러 번 요청을 보내더라도 시스템은 항상 동일한 결과를 반환하고, 불필요한 리소스 소모나 상태 변경을 피할 수 있습니다.
5. 실제 예시
결제 처리 API 예시:
json
코드 복사
POST /payments
{
  &quot;amount&quot;: 100,
  &quot;currency&quot;: &quot;USD&quot;,
  &quot;idempotencyKey&quot;: &quot;12345&quot;
}
첫 번째 요청: 서버는 idempotencyKey: &quot;12345&quot;를 인식하고 결제를 처리한 후, 결제 정보를 반환합니다.
두 번째 요청 (같은 Idempotency Key): 서버는 이미 idempotencyKey: &quot;12345&quot;에 대한 요청을 처리했음을 인식하고, 결제를 중복 처리하지 않고 이전 응답을 그대로 반환합니다.
6. Idempotency Key 관리 방법
서버에서 Key를 저장: 서버는 각 Idempotency Key와 관련된 요청을 처리하고, 그 결과를 저장합니다. 일정 기간 동안 같은 idempotencyKey가 사용되면 서버는 그 결과를 반환하고, 이후에는 해당 키를 삭제하거나 만료시킬 수 있습니다.

유효 기간 설정: idempotencyKey는 보통 일정 기간 동안만 유효하며, 이를 통해 서버의 메모리나 저장소에 과도한 부하를 줄일 수 있습니다.

7. 결론
Idempotency Key는 멱등성을 보장하는 중요한 도구입니다. POST 메서드에서 중복 요청으로 인한 트랜잭션 문제를 방지하고, 동일한 작업을 여러 번 요청해도 한 번만 처리되도록 보장합니다. 결제 처리, 주문 생성, 리소스 생성 등 중복된 작업을 방지해야 하는 중요한 작업에서 널리 사용됩니다.

```



&lt;/details&gt;

&lt;h2 id=&quot;멱등성이-중요한-이유&quot;&gt;멱등성이 중요한 이유&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;일관성 : 보통 반복되는 요청이 단일 요청과 동일한 효과를 갖도록 보장하는 것은 시스템 전반에 걸쳐 일관된 상태를 유지하는 데 도움이 됩니다.&lt;/li&gt;
  &lt;li&gt;유지보수성 : 멱등성을 가진 HTTP메서드로 AP로 통신하는 부분에 있어서는 재시도를 처리할 때의 사이드이펙트를 고려한 복잡한 로직을 구현할 필요가 없기 때문에 이 부분을 잘 고려해서 설계한다면 유지보수성이 증가 됩니다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Network" /><category term="개념 정리" /><summary type="html">네트워크 CS 지식 정리</summary></entry><entry><title type="html">Effective TypeScript - 2</title><link href="https://hoex5h.github.io/Effective_TypeScript_-_2" rel="alternate" type="text/html" title="Effective TypeScript - 2" /><published>2025-01-14T03:54:00+00:00</published><updated>2025-01-14T03:54:00+00:00</updated><id>https://hoex5h.github.io/Effective_TypeScript_-_2</id><content type="html" xml:base="https://hoex5h.github.io/Effective_TypeScript_-_2">&lt;blockquote&gt;
  &lt;p&gt;이펙티브 타입스크립트 책과&lt;br /&gt;
이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;타입스크립트-컴파일러-역할&quot;&gt;타입스크립트 컴파일러 역할&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;구 버전 브라우저를 위한 트랜스파일 -&amp;gt; Babel 의 역할이었던거 같은데?&lt;/li&gt;
  &lt;li&gt;코드의 타입 오류 체크&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 역할은 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적&lt;/code&gt;이다. 서로의 작업에 영향을 주지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;타입-오류가-있어도-컴파일이-가능&quot;&gt;타입 오류가 있어도 컴파일이 가능&lt;/h2&gt;

&lt;p&gt;컴파일은 타입 체크와 독립적으로 동작하므로 오류 있어도 컴파일은 가능&lt;/p&gt;

&lt;p&gt;만약 오류가 있을 때 컴파일 하고 싶지 않으면 tsconfig.json 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noEmitError&lt;/code&gt; 옵션을 true 로 주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;런타임에는-타입-체크-불가능&quot;&gt;런타임에는 타입 체크 불가능&lt;/h2&gt;

&lt;p&gt;타입스크립트에서 자바스크립트로 컴파일되면서 타입이나 인터페이스 같은 경우 전부 제거된다.
즉, 런타임 시점에서 타입과 인터페이스는 아무런 역할을 하지 못한다.&lt;/p&gt;

&lt;h2 id=&quot;함수-오버로딩-불가능&quot;&gt;함수 오버로딩 불가능&lt;/h2&gt;

&lt;p&gt;선언문은 타입 별로 여러개 선언은 가능하다. 하지만 구현체는 오직 하나다.&lt;/p&gt;

&lt;h2 id=&quot;덕타이핑&quot;&gt;덕타이핑&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://hoeeeeeh.github.io/javascript/2024/07/29/day1112.html#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-interface-duck-typing&quot;&gt;interface 와 duck-typing&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;any-타입-꼭-써야겠어&quot;&gt;Any 타입, 꼭 써야겠어?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;any 타입 쓰면 타입에 안전성이 없다. 쓰면 number 타입에 string 이 할당될 수도 있어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 함수의 시그니처(약속/의도 정도로 해석?)가 무시된다.&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 자동완성 기능, 코드 리팩토링 도구 쓰기 힘들어져 -&amp;gt; 생산성 떨어진다!&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 코드 리팩토링할 때 버그를 찾기 힘들어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 타입 설계의 의도, 상태 등이 감춰져서 설계를 해석하기 힘들어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 실수가 빈번해져&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이래도 any 타입, 꼭 사용하셔야겠습니까?&lt;/p&gt;

&lt;p&gt;근데 불가피하게 any 타입을 꼭 써야할 때가 있다. 이는 5장에서 다룬다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="TypeScript" /><summary type="html">이펙티브 타입스크립트 책과 이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.</summary></entry><entry><title type="html">Effective TypeScript - 1</title><link href="https://hoex5h.github.io/Effective_TypeScript_-_1" rel="alternate" type="text/html" title="Effective TypeScript - 1" /><published>2025-01-14T03:52:00+00:00</published><updated>2025-01-14T03:52:00+00:00</updated><id>https://hoex5h.github.io/Effective_TypeScript_-_1</id><content type="html" xml:base="https://hoex5h.github.io/Effective_TypeScript_-_1">&lt;blockquote&gt;
  &lt;p&gt;이펙티브 타입스크립트 책과&lt;br /&gt;
이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;ts-js&quot;&gt;TS, JS&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입스크립트는 자바스크립트의 상위 집합&lt;/code&gt; 이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입스크립트는 타입이 정의된 자바스크립트의 상위 집합이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;모든 JS 프로그램이 TS 라는 명제는 참, 반대는 성립하지 않는다.&lt;/p&gt;

&lt;h1 id=&quot;ts-타입체커&quot;&gt;TS 타입체커&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
// ts
let sample = &quot;this is a sample&quot;;
console.log(sample.uppercase());
// uppercase 라는 메소드가 string 형식에 없다!
// toUpperCase() 를 사용하시겠습니까?


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런식으로 sample 이 string 이라는걸 명시해주지 않아도 타입스크립트는 초기값으로부터 추론한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;코드의 의도가 무엇인지 타입 구문을 통해 타입스크립트에게 알려줄 수 있기 때문에 코드의 동작과 의도가 다른 부분을 찾을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코드의 의도를 표현하려면 명시적으로 선언해라 ex) interface&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
interface person {
  name: string;
  age: number;
}

const people: Person[] = [
  // Person 예시
  { name: &quot;John&quot;, age: 5 },
  //...
];


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;자동-형변환-체크&quot;&gt;자동 형변환 체크?&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
const a = 2 + &quot;3&quot;; // 자바스크립트 런타임에서 정상, String 타입의 &apos;23&apos;
const b = null + 7; // 자바스크립트 런타임에서 정상, Number 타입의 7, 그러나 typescript 는 오류를 발생시킴
const c = [] + 12; // 자바스크립트 런타임에서 정상, String 타입의 &apos;12&apos;, 그러나 typescript 는 오류를 발생시킴
// 근데 이건 왜 String 타입이 되는걸까?
alert(&quot;Hi&quot;, &quot;world&quot;); // 자바스크립트 런타임에서 정상, 앞의 &quot;Hi&quot; 만 나옴. 하지만 alert는 arg가 0개~1개 인데 2개를 가져왔다고 ts 오류


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;모든걸-다-잡아주지는-않는다&quot;&gt;모든걸 다 잡아주지는 않는다.&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
const a = [&quot;hi&quot;];
console.log(a[2]); // 컴파일은 정상, 런타임에서 오류


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문법의 엄격함은 온전히 취향의 차이이다.&lt;/p&gt;

&lt;h1 id=&quot;타입스크립트-컴파일러의-셋팅에-따라-바뀐다&quot;&gt;타입스크립트 컴파일러의 셋팅에 따라 바뀐다.&lt;/h1&gt;

&lt;p&gt;tsconfig.json 파일에서 여러 옵션으로 셋팅을 줄 수 있다. 타입스크립트를 어떻게 사용할 지 동료들에게 알려줄 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noImplicitAny&lt;/code&gt; 옵션은 타입 선언이 없으면 암시적으로 any 타입으로 선언하는 옵션인데, false 와 true 로 옵션을 켜고 끌 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strictNullChecks&lt;/code&gt; 는 모든 타입에 null 과 undefined 를 할당할 수 있는지에 대한 옵션이다.&lt;/p&gt;

&lt;p&gt;null 을 명시적으로 허용하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const x : number | null = null;&lt;/code&gt; 처럼 사용하는 것이 좋다. 만약 이렇게 되면 Null check 를 위한 assertion(단언문) 이 필요하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
if (x.abc) {
  // null 이 아닐때
}
x!.abc; // x가 Null 이 아니라고 단언한다


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;웬만하면 noImplicit, strictNullChecks 는 설정해두고 시작해라. 안그러면 undefined is not a Object 오류를 계속 만날 것이다.&lt;/p&gt;

&lt;p&gt;엄격하게 잡고 싶으면 그냥 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strict&lt;/code&gt; 옵션을 true 로 줘라.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="TypeScript" /><summary type="html">이펙티브 타입스크립트 책과 이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.</summary></entry><entry><title type="html">[Swift] @AppStorage</title><link href="https://hoex5h.github.io/Swift-_@AppStorage" rel="alternate" type="text/html" title="[Swift] @AppStorage" /><published>2025-01-14T03:52:00+00:00</published><updated>2025-01-14T03:52:00+00:00</updated><id>https://hoex5h.github.io/%5BSwift%5D_@AppStorage</id><content type="html" xml:base="https://hoex5h.github.io/Swift-_@AppStorage">&lt;h1 id=&quot;appstorage&quot;&gt;@AppStorage&lt;/h1&gt;

&lt;p&gt;Swift 에서도 코틀린처럼 기기 내부에 데이터를 저장할 수 있는 방법이 있다.&lt;/p&gt;

&lt;p&gt;코틀린에서는 SharedPreference 를 사용했었는데, Swift 에서는 @AppStorage 를 사용한다.&lt;/p&gt;

&lt;p&gt;다만 차이점이 있었는데,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
@AppStorage(&quot;onboarding&quot;) var isOnboardingViewActive : Bool = true


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드대로만 보면 어느 파일에서든 “onboarding” 프로퍼티를 사용하려면 true(혹은 false) 로 초기화를 해야하는 것처럼 보인다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사실은 계속 초기화가 되는 것이 아니라, 기기 내부 저장소에서 onboarding 프로퍼티를 찾지 못하는 경우에만 true로 초기화 한다는 뜻이고, 이미 존재한다면 해당 초기화 구문은 무시된다고 한다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="Swift" /><summary type="html">@AppStorage</summary></entry><entry><title type="html">[Swift] Cocoa Pod install Error</title><link href="https://hoex5h.github.io/Swift-_Cocoa_Pod_install_Error" rel="alternate" type="text/html" title="[Swift] Cocoa Pod install Error" /><published>2025-01-14T03:52:00+00:00</published><updated>2025-01-14T03:52:00+00:00</updated><id>https://hoex5h.github.io/%5BSwift%5D_Cocoa_Pod_install_Error</id><content type="html" xml:base="https://hoex5h.github.io/Swift-_Cocoa_Pod_install_Error">&lt;h1 id=&quot;cocoa-pod-install-error&quot;&gt;Cocoa Pod install Error&lt;/h1&gt;

&lt;h2 id=&quot;에러-내용&quot;&gt;에러 내용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
You may have encountered a bug in the Ruby interpreter or extension libraries.
Bug reports are welcome.
For details: &amp;lt;https://www.ruby-lang.org/bugreport.html&amp;gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;원인&quot;&gt;원인&lt;/h3&gt;

&lt;p&gt;M1 맥북에서 일어나는 버그라고 하는데,, M1이 출시한지 이렇게나 오래 되었는데 아직도 ㅠ&lt;/p&gt;

&lt;h2 id=&quot;해결-방법&quot;&gt;해결 방법&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
$ sudo arch -x86_64 gem install ffi
$ arch -x86_64 pod install


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 해서 해결할 수 있다고 한다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="Swift" /><summary type="html">Cocoa Pod install Error</summary></entry><entry><title type="html">Dependency Injection</title><link href="https://hoex5h.github.io/Dependency_Injection" rel="alternate" type="text/html" title="Dependency Injection" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/Dependency_Injection</id><content type="html" xml:base="https://hoex5h.github.io/Dependency_Injection">&lt;p&gt;Dependency Injection ( Angular 공식 문서 )&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.nestjs.com/providers&quot;&gt;nest.js 공식문서&lt;/a&gt;를 읽어보는 도중 DI 관련한 문서에 대한 링크로 &lt;a href=&quot;https://www.angular.kr/guide/dependency-injection&quot;&gt;Angular 의 공식 문서&lt;/a&gt;를 걸려있었다.&lt;/p&gt;

&lt;p&gt;자세하게, 한국어로도 적혀있는 것 같아서 nestjs 를 쓰기 전에 꼼꼼히 읽어보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;의존성-주입은-왜-사용할까&quot;&gt;의존성 주입은 왜 사용할까?&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dependency Injection, or DI, is a design pattern and mechanism for creating and delivering some parts of an application to other parts of an application that require them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;의존성 주입은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션의 일부(A)&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;또 다른 곳(B)&lt;/code&gt;에서 필요로 할 때, A 를 만들고 전달하는 역할을 한다.&lt;/p&gt;

&lt;p&gt;즉 다른 클래스에 있는 기능을 사용하고 싶을 때 의존성을 주입해주는 것이라고 생각하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;의존성을-사용하는-쪽-제공하는-쪽&quot;&gt;의존성을 사용하는 쪽, 제공하는 쪽&lt;/h1&gt;

&lt;p&gt;단순하게 의존성을 주입 하는 것은 어떤 방식으로든 하나의 객체에 다른 클래스의 객체를 넘기기만 해도 의존성 주입이라고 부를 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class Foo {
    constructor(){
        // ...
    }
}

class UsingDI {
    constructor(private injectClass)
}

class DoNotUseDI {
    constructor(){
        this.injectClass = new Foo();
    }
}



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시대로라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DoNotUseDI&lt;/code&gt; 객체는 직접 Foo 객체를 생성해서 사용한다.&lt;/p&gt;

&lt;p&gt;따라서 아주 강한 결합을 가지게 되는데, 만약 나중에 Foo 가 아니라 Bar 라는 클래스로 바꾸고 싶다고 하면
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DoNotUseDI&lt;/code&gt; 클래스의 코드도 수정해야하고 테스트할 때도 꼭 Foo 객체를 넣어줘야 하기 때문에 복잡해지게 될 것이다.&lt;/p&gt;

&lt;p&gt;반면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UsingDI&lt;/code&gt; 클래스는 생성자로 어떤 객체를 넘기느냐에 따라, 그 객체에 결합이 생긴다. 위의 예시에 비해 더 동적으로 의존성이 생긴다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 Foo 의존성을 주입했다가, 나중에는 Bar 객체를 주입할 수도 있고, 또 나중에는 어떤 객체라도 덕타이핑에 문제가 없다면 (일단은) 주입할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;또한 테스트할 때도 굳이 실제 객체를 넣어줄 필요 없이 간단한 모킹 객체를 넣어줄 수도 있을 것이다.&lt;/p&gt;

&lt;p&gt;다만 여기서 기억해두어야 할 점은 의존성은 사용하는 쪽(주입 당하는 쪽) 과 제공하는 쪽(주입하는 쪽) 이 있다는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;의존성-주입&quot;&gt;의존성 주입&lt;/h1&gt;

&lt;h2 id=&quot;injector&quot;&gt;Injector&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;injector&lt;/code&gt; 객체는, 미리 생성된 프로바이더(의존성을 제공당할 수 있는 클래스) 대로 의존성 객체를 생성하고 캐싱해둔다.&lt;/p&gt;

&lt;p&gt;또한 인젝터는 (기본적으로) 의존성 객체들을 싱글톤 인스턴스로 관리한다.&lt;/p&gt;

&lt;h2 id=&quot;모듈에-따라&quot;&gt;모듈에 따라?&lt;/h2&gt;

&lt;p&gt;NestJS 의 컴포넌트는 크게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모듈&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로바이더&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨트롤러&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스&lt;/code&gt; 등으로 계층을 나눌 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
@Module({
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}

@Module({
  imports: [CatsModule],
  controllers: [DogsController],
})
export class DogsModule {}



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시처럼 NestJS 모듈 별로 프로바이더, 서비스, 컨트롤러 등등을 주입받는데 모듈별로 injector 가 생성되고 해당 인젝터가 의존성 객체들을 캐싱하고 있다.&lt;/p&gt;

&lt;p&gt;또한 CatsModule 에 주입된 CatsService 를 export 함으로써 DogsModule 에서 CatsModule 의 프로바이더를 가져와서 사용할 수 있게 된다.&lt;/p&gt;

&lt;h2 id=&quot;injectable--의존성-주입-가능&quot;&gt;@Injectable : 의존성 주입 가능&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
@Injectable
class CatService {}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래스를 의존성으로 주입하려면 가장 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Injectable&lt;/code&gt; 데코레이터를 사용해야한다.&lt;/p&gt;

&lt;h2 id=&quot;module--의존성-등록&quot;&gt;@Module : 의존성 등록&lt;/h2&gt;

&lt;p&gt;NestJs 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Module&lt;/code&gt; 로 의존성을 등록해줄 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;프로바이더-scope&quot;&gt;프로바이더 Scope&lt;/h2&gt;

&lt;p&gt;의존성 객체가 되는 프로바이더의 생명 주기는 애플리케이션의 생명 주기와 같다. 애플리케이션이 부트스트랩 될 때, 모든 의존성은 해결(사용 가능)이 되어야 한다.
그렇기 때문에 애플리케이션이 부트스트랩 될 때, 모든 프로바이더들이 인스턴트화 되어야 하고 애플리케이션이 종료될 때 모든 프로바이더들은 제거된다.&lt;/p&gt;

&lt;p&gt;만약 프로바이더의 Scope 를 직접 정하고 싶다면, &lt;a href=&quot;https://docs.nestjs.com/fundamentals/injection-scopes&quot;&gt;request-scoped&lt;/a&gt; 의 방법을 사용할 수 있다고도 한다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="TypeScript" /><category term="NestJS" /><summary type="html">Dependency Injection ( Angular 공식 문서 )</summary></entry><entry><title type="html">Express.js 따라 만들기</title><link href="https://hoex5h.github.io/Express.js_%EB%94%B0%EB%9D%BC_%EB%A7%8C%EB%93%A4%EA%B8%B0" rel="alternate" type="text/html" title="Express.js 따라 만들기" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/Express.js_%EB%94%B0%EB%9D%BC_%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="https://hoex5h.github.io/Express.js_%EB%94%B0%EB%9D%BC_%EB%A7%8C%EB%93%A4%EA%B8%B0">&lt;p&gt;ts/js 로 express 따라 만들기&lt;/p&gt;

&lt;h1 id=&quot;tsjs-로-express-따라-만들기&quot;&gt;ts/js 로 express 따라 만들기&lt;/h1&gt;

&lt;p&gt;node 로 웹 서버를 만들때부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;express&lt;/code&gt; 를 자주 사용했었는데 express 의 내부 동작은 잘 알지 못한채로 그저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.use&lt;/code&gt; 를 사용했던 것 같다.&lt;/p&gt;

&lt;p&gt;그래서 이번 기회에 express 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt; 으로 구현해보려고 한다.&lt;/p&gt;

&lt;h2 id=&quot;http-모듈이-아니라-왜-socket-을-사용해야할까&quot;&gt;http 모듈이 아니라 왜 socket 을 사용해야할까?&lt;/h2&gt;

&lt;p&gt;일단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹 서버&lt;/code&gt; 라는걸 생각해보면 당연히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http&lt;/code&gt; 모듈을 사용하는 것이 편하다.&lt;/p&gt;

&lt;p&gt;소켓으로 구현한다고 해도 클라이언트가 http 프로토콜로 보낸다면 웹 서버에서도 소켓을 http 모듈처럼 사용해야할 것이다.&lt;/p&gt;

&lt;p&gt;그럼에도 socket 으로 구현해보면 좋은 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결국 http 통신도 소켓 통신&lt;/code&gt; 이라는 것이다.&lt;/p&gt;

&lt;p&gt;node 의 &lt;a href=&quot;https://nodejs.org/api/http.html#class-httpserver&quot;&gt;http 모듈&lt;/a&gt;에서 서버를 생성할 때, 결국 &lt;a href=&quot;https://nodejs.org/api/net.html#class-netserver&quot;&gt;소켓 모듈&lt;/a&gt; 을 상속받아서 사용한다.&lt;/p&gt;

&lt;p&gt;소켓 모듈은 &lt;a href=&quot;https://nodejs.org/api/events.html#class-eventemitter&quot;&gt;EventEmitter&lt;/a&gt; 모듈을 상속받는데, 데이터가 들어오거나 소켓 연결이 생성되거나 끊어졌을 때 등의 이벤트가 발생하게끔 만들어졌기 때문이다.&lt;/p&gt;

&lt;p&gt;그래서 소켓을 활용한다는것은 node.js 개발자로서 가장 아래까지 내려가볼 수 있는 기회라고 생각한다.&lt;/p&gt;

&lt;p&gt;추후에는 handshake 과정까지 만들어보고싶다.&lt;/p&gt;

&lt;p&gt;그래도 추후에 꼭 네트워크 공부는 추가로 하자..&lt;/p&gt;

&lt;h2 id=&quot;socket-으로-listen&quot;&gt;Socket 으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Listen&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Socket 으로 Express 를 구현하기로 했으니 당연하게도 socket 을 활용해서 서버를 만들어야한다.&lt;/p&gt;

&lt;p&gt;이는 위에서 언급했던 node 의 &lt;a href=&quot;https://nodejs.org/api/net.html#class-netserver&quot;&gt;net.server&lt;/a&gt; 를 활용하면 된다.&lt;/p&gt;

&lt;p&gt;여기서 우리가 만들 Express 가 net.server 를 상속받을지, 아니면 net.Server 객체를 그냥 사용할지에 대해서 고민을 할 수 있는데
net.Server 를 상속받는다는 것은 net.Server 의 메소드를 오버라이딩 한다든지, 추가 메소드를 만드는 등의 작업이 있을 경우 유효하다고 생각한다.&lt;/p&gt;

&lt;p&gt;우리의 커스텀 Express 에서는 net.Server 의 메소드들을 사용할 것이지, 추가로 메소드를 생성/변경 등을 하지 않을 것 같아서 상속 받지는 않을 예정이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
import net from &apos;net&apos;;

class Express {

  listen(port: number, callback: () =&amp;gt; void) {

    const server = net.createServer((socket) =&amp;gt; {
      socket.on(&apos;data&apos;, (data) =&amp;gt; {
        /*
            ...
            TODO: socket 으로 넘어온 Request 를 Express 에서 쓸 수 있도록 파싱
            ...
        */
      });
    });

    server.listen(port, () =&amp;gt; {
      callback();
    });

  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;net.CreateServer 를 통해서 tcp 연결을 만들고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생했을 때 데이터들을 가지고 우리가 사용하기 편하도록 파싱하는 과정을 거치면 될 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;-socket-은-stream-이다&quot;&gt;🤔 socket 은 stream 이다!&lt;/h3&gt;

&lt;p&gt;여기서 생각해보면 좋을 점은 socket 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stream&lt;/code&gt; 을 활용한다.&lt;/p&gt;

&lt;p&gt;node 의 &lt;a href=&quot;https://nodejs.org/api/net.html#class-netsocket&quot;&gt;net.Socket&lt;/a&gt; 은 &lt;a href=&quot;https://nodejs.org/api/stream.html#class-streamduplex&quot;&gt;stream.Duplex&lt;/a&gt; 를 상속받아서 사용하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream 에 대한 정리는 여기서 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 클라이언트가 보낸 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든 데이터&lt;/code&gt; 가 수신될 때까지 기다리는게 아니라 stream 으로 (순차적으로) 데이터가 들어오면 그 즉시 버퍼에 쌓이고
버퍼에 데이터가 일정량 이상 쌓일 때마다 chunk 단위로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생한다.&lt;/p&gt;

&lt;p&gt;(보통은 버퍼가 넘치기 전에, 혹은 데이터가 전부 다 들어왔을 때 ‘data’ 이벤트가 발생한다.)&lt;/p&gt;

&lt;p&gt;다시 말해서 들어오는 데이터가 크다면 데이터가 나누어져서 들어올 수 있다 ( === 한 번의 통신에 여러 번의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생할 수 있다) 는 이야기이다.&lt;/p&gt;

&lt;p&gt;따라서 buffer 의 크기보다 큰 데이터를 클라이언트에서 보냈다면, 여러 번의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 이벤트가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;실시간으로 데이터를 처리해야하는(ex. 유튜브 같은 영상 스트림) 경우에는 들어오는 데이터마다 처리를 해주면 된다.&lt;/p&gt;

&lt;p&gt;반면에 용량이 매우 큰 이미지/동영상 파일은 모든 chunk 들을 다 합쳐서 하나로 만들어야할 것이다.&lt;/p&gt;

&lt;p&gt;이에 대한 처리까지 있으면 좋을 것 같다!&lt;/p&gt;

&lt;h2 id=&quot;소켓-통신을-http-통신-처럼&quot;&gt;소켓 통신을 http 통신 처럼&lt;/h2&gt;

&lt;p&gt;http 모듈을 사용한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소켓 통신으로 들어오는 Request&lt;/code&gt; 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Express 의 Request&lt;/code&gt; 처럼 바꿔줄 필요가 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 socket 으로 들어온 HTTP Request 는 아래처럼 들어올 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
GET /favicon.ico HTTP/1.1
Host: localhost:3000
Connection: keep-alive
sec-ch-ua-platform: &quot;macOS&quot;
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36
sec-ch-ua: &quot;Chromium&quot;;v=&quot;129&quot;, &quot;Not=A?Brand&quot;;v=&quot;8&quot;
DNT: 1
sec-ch-ua-mobile: ?0
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: image
Referer: &amp;lt;http://localhost:3000/index.html&amp;gt;
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Cookie: sid=1234; coo=11

helloworld this is a body


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 하나의 거대한 문자열을 잘 파싱해서 우리의 express 에서 쓰기 편하도록 쉽게 만드는 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;파싱의 큰 기준은 두 가지 이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Header 와 Body 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\r\\n\\r\\n&lt;/code&gt; 으로 구분된다.&lt;/li&gt;
  &lt;li&gt;Header 끼리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\r\\n&lt;/code&gt; 으로 구분된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;맨 윗 줄을 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET /favicon.ico HTTP/1.1&lt;/code&gt; 이라고 나오는데&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Method&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protocol&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Version&lt;/code&gt; 으로 구분해주어 아래 처럼 하나의 객체로 만들어주자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class ExpressRequest {
  headers?: Header;

  body: string | object = &apos;&apos;;

  method?: string;

  // 전체 url
  url?: string;

  protocol?: string;

  version?: string;
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-url-의-query-부분이나-params-부분도-처리하자&quot;&gt;🤔 url 의 Query 부분이나 Params 부분도 처리하자&lt;/h3&gt;

&lt;h3 id=&quot;params&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Params&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;실제로 express 를 써보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.use(&apos;/card/:username/:cardId, ...)&lt;/code&gt; 와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; 를 사용하는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;사용자가 Request 를 보낼 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/card/hoeh/3?columnId=5&amp;amp;columnName=today&lt;/code&gt; 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; 문자 이후에 있는 query 도 있을 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 위에서 파싱한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url&lt;/code&gt; 부분에서 query, param 부분도 분리해주면 좋을 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class ExpressRequest {
  headers?: Header;

  body: string | object = &apos;&apos;;

  method?: string;

  // 전체 url
  url?: string;

  protocol?: string;

  version?: string;

  // 여기까지가 SocketRequest

  // /user/:id 에서 id
  params: object = {};

  // /search?keyword=naver { keyword : naver }
  query: object = {};

  // /user?id=123 에서 /user
  path?: string;
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로, url 로 부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;params&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt; 까지 파싱해서 Request 에 넣어주도록 하자.&lt;/p&gt;

&lt;p&gt;파싱할 때는 node 의 &lt;a href=&quot;https://nodejs.org/api/querystring.html&quot;&gt;querystring&lt;/a&gt; 모듈과 &lt;a href=&quot;https://www.npmjs.com/package/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; 을 활용해보자.&lt;/p&gt;

&lt;h2 id=&quot;appuse&quot;&gt;app.use()&lt;/h2&gt;

&lt;p&gt;app.use 는 무엇을 하는 메소드일까? express 를 사용할 때면 이런식으로 사용했던 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
app.use(&apos;/card&apos;, (req, res, next) =&amp;gt; {
  // ...
  res.send(&apos;helloworld&apos;);
});


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/card&lt;/code&gt; 의 url 로 들어온 요청에 대해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(req, res, next) =&amp;gt; {}&lt;/code&gt; 에 해당하는 함수를 실행하는 것 같은데 그렇다면
이 함수는 무슨 함수일까?&lt;/p&gt;

&lt;h3 id=&quot;middleware-layer-router&quot;&gt;Middleware, Layer, Router&lt;/h3&gt;

&lt;p&gt;express 에서는 이런 함수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;middleware&lt;/code&gt; 라고 부른다. 미들웨어는 말 그대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중간에 끼어있는&lt;/code&gt; 함수로 보면 된다.&lt;/p&gt;

&lt;p&gt;Request 를 받아서, Response 를 보내기 전의 중간 처리 과정을 하는 함수를 전부 middleware 라고 부른다.&lt;/p&gt;

&lt;p&gt;그러면 express 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개발자가 middleware 를 등록해서 모든 요청마다 url 을 검사해서, url 조건을 충족하면 등록된 middleware 를 실행한다&lt;/code&gt; 의 흐름으로 진행하는구나!&lt;/p&gt;

&lt;p&gt;라고 간단하게 생각했는데 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Layer&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Router&lt;/code&gt; 의 개념이 또 등장한다.&lt;/p&gt;

&lt;p&gt;Layer 가 무엇인지 보니, middleware 를 한 번 감싸주는 계층이다.&lt;/p&gt;

&lt;p&gt;엥? Layer 로 굳이 감싸는 이유가 뭐야? 라고 생각이 들었는데 여러가지 이유가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Method, Url 검사&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;middleware 가 실행되기 전에 사용자가 등록한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/card&lt;/code&gt; url 과 들어온 Request 의 url 을 비교해야 한다.&lt;/p&gt;

&lt;p&gt;또한 특정 메소드의 요청에만 미들웨어를 실행되게 등록했다면 Method 비교도 해야할 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;에러 처리&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사용자가 등록한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(req, res, next) =&amp;gt; {}&lt;/code&gt; 함수에서 에러를 처리하려면, 미들웨어 안에서 try, catch 를 작성해야하는데 그렇다면 모든 미들웨어에 try, catch 가 있어야 한다.&lt;/p&gt;

&lt;p&gt;실제 express 에서는 만약 에러가 발생하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next(err)&lt;/code&gt; 의 방법으로 다음 미들웨어로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt; 를 넘긴다.
Layer 계층에서는 middleware 를 실행하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt; 가 넘어왔는지 확인하고, 넘어왔다면 에러가 발생했다고 판단해서 에러를 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;즉 Layer 계층에서 전역적으로 에러를 처리해줄 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;같은 Url, Method 에 여러 개의 미들웨어 등록&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;말 그대로 여러 개의 미들웨어가 등록된다면 이를 관리하는 계층이 필요할 수 밖에 없다.&lt;/p&gt;

&lt;h3 id=&quot;-layer-안에서-next&quot;&gt;🤔 Layer 안에서 next&lt;/h3&gt;

&lt;h3 id=&quot;-middleware-가-비동기일-경우에-에러-핸들링&quot;&gt;🤔 Middleware 가 비동기일 경우에 에러 핸들링&lt;/h3&gt;

&lt;h2 id=&quot;response-객체로-socketwrite&quot;&gt;Response 객체로 socket.write&lt;/h2&gt;

&lt;h3 id=&quot;-response-에-header-와-body-를-따로-write-하기&quot;&gt;🤔 Response 에 Header 와 Body 를 따로 write 하기&lt;/h3&gt;

&lt;h2 id=&quot;커스텀-express-를-활용해서-웹-서버-코드-작성&quot;&gt;커스텀 express 를 활용해서 웹 서버 코드 작성&lt;/h2&gt;

&lt;h3 id=&quot;만들어둔-express-를-로컬-모듈로-바꿔보자&quot;&gt;만들어둔 express 를 로컬 모듈로 바꿔보자&lt;/h3&gt;

&lt;h2 id=&quot;타입스크립트-타입을-위한-dts-만들기&quot;&gt;타입스크립트 타입을 위한 d.ts 만들기&lt;/h2&gt;

&lt;p&gt;만약 자바스크립트로 http, express 코드를 작성하고 실제 app 은 타입스크립트로 작성한다면&lt;/p&gt;

&lt;p&gt;http, express 에 타입을 명시해주는 d.ts 가 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;express-에서는-request-의-dto-를-직접-검사해줘야한다&quot;&gt;Express 에서는 Request 의 DTO 를 직접 검사해줘야한다&lt;/h3&gt;

&lt;h2 id=&quot;zod-를-활용해보자&quot;&gt;ZOD 를 활용해보자&lt;/h2&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Project&quot;]" /><category term="[&quot;Project&quot;]" /><category term="Project" /><category term="JavaScript" /><category term="TypeScript" /><summary type="html">ts/js 로 express 따라 만들기</summary></entry><entry><title type="html">Gateway, 사설망, CIDR</title><link href="https://hoex5h.github.io/Gateway,_%EC%82%AC%EC%84%A4%EB%A7%9D,_CIDR" rel="alternate" type="text/html" title="Gateway, 사설망, CIDR" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/Gateway,_%EC%82%AC%EC%84%A4%EB%A7%9D,_CIDR</id><content type="html" xml:base="https://hoex5h.github.io/Gateway,_%EC%82%AC%EC%84%A4%EB%A7%9D,_CIDR">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=kYiQGpPVnyI&quot;&gt;IP 주소를 묶는 방법, CIDR란?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;network-gateway-사설망-cidr&quot;&gt;[Network] Gateway, 사설망, CIDR&lt;/h1&gt;

&lt;h2 id=&quot;ipv4&quot;&gt;IPv4&lt;/h2&gt;

&lt;p&gt;우선 IPv4 는 총 32 비트의 숫자로 구성 되어 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;XXX.XXX.XXX.XXX 각각 8비트씩 -&amp;gt; 2^32개!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 중에서 일부 ip가 특수한 목적으로 선점되어 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사설 ip, 루프백 ip, 멀티캐스트 ip, 0.0.0.0(현 주소), 브로드캐스트 ip…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;실제로 사용할 수 있는 ip 는 2^32 보다 적다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예전에는 모든 기기에 하나씩 ip 를 할당해도 여유로웠겠지만, 기기들이 늘어난 요새는 매우 힘들다.&lt;/p&gt;

&lt;p&gt;따라서 사설망(private network)이 필요로 해졌다.&lt;/p&gt;

&lt;h2 id=&quot;사설망private-network&quot;&gt;사설망(private network)&lt;/h2&gt;

&lt;p&gt;여러대의 기기를 하나의 사설망으로 묶고, 중복되지 않도록 사설 ip를 할당해준다.&lt;/p&gt;

&lt;p&gt;이때 외부와 통신하기 위해서는 public ip 를 가지고 있는 장비가 필요한데, 이것이 Gateway 이다.&lt;/p&gt;

&lt;h2 id=&quot;gateway&quot;&gt;Gateway&lt;/h2&gt;

&lt;p&gt;게이트웨이는 다른 대역으로 라우팅을 해줄 수 있는, 주로 L3 스위치급 이상의 장비이다.&lt;/p&gt;

&lt;p&gt;가장 많이 보이는 것은 역시 어느 집에서나 볼 수 있는 공유기다. 사설망에 있는 장비들이 외부와 통신하려고 할 때, Gateway 를 거쳐서 통신하게 되는데 Gateway 는 public ip 를 하나 할당받고, NAT(Network Address Translation) 기능을 사용하여 내부 네트워크에서 오는 여러 요청을 public IP 주소를 사용하여 외부로 전송하고, 외부에서 돌아오는 응답을 올바른 내부 장치로 전달한다. 만약 사설망의 여러 장비가 같은 목적지의 같은 포트로 통신을 하려고 한다면 게이트웨이는 NAT 테이블을 활용하여 각각의 내부 소스 IP 주소와 포트 번호를 기반으로 이 요청들을 기억하고 구분한다. 외부로 나갈 때는 일반적으로 변형된 소스 포트를 사용하여, 응답이 돌아올 때 원래의 내부 IP 주소와 포트로 정확히 매핑한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들어 A 컴퓨터(192.168.0.2)가 (168.126.63.1, 443포트)에, B 컴퓨터(192.168.0.3)가 다음(168.126.63.1, 80포트)에 동시에 접근한다고 하자.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A와 B의 목적지 ip는 동일하지만 포트가 다르기 때문에 443포트와 80포트로 A/B 의 요청을 구분할 수 있다.


하지만 만약 A와 B 모두 443포트와 통신하려고 한다면 어떻게 될까?


443포트에서 오는 응답을 A에게 전달해야할지, B에게 전달해야할지 구분해야 하기 때문에 Gateway는 A가 보낸 요청을 4430, B가 보낸 요청을 4431 포트로 변경해서 NAT 테이블에 저장한다. 이제 게이트웨이는 4430 포트로 응답이 돌아오는지, 4431 포트로 응답이 돌아오는지에 따라 A,B 컴퓨터에 알맞게 응답을 돌려줄 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;cidrclassless-inter-domain-routing&quot;&gt;CIDR(Classless Inter Domain Routing)&lt;/h2&gt;

&lt;p&gt;CIDR는 여러 개의 사설망을 구축하기 위해 망을 나누는 방법이다. 여기서 왜 Classless 라는 단어가 사용되었냐 하면, 옛날에는 A/B/C/D 클래스를 이용해서 망을 나눴기 때문이다. CIDR 을 쓰면 ABCD 클래스를 포함해서 더 다양하게 망을 나눌 수 있기 때문에 굳이 클래스라는 단어로 표기하기 않아도 되기 때문이다.&lt;/p&gt;

&lt;p&gt;CIDR의 기본적인 표기법은 192.168.0.0/24 처럼, A.B.C.D/E 와 형식이다. 그렇다면 이런 형식은 어떻게 해석할 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.0/24&lt;/code&gt; 라는 예시로 살펴보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/24&lt;/code&gt; 의 뜻은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;앞에서부터 24비트 이후에 오는 비트들을 사용할 수 있다&lt;/code&gt; 라는 뜻이다. 조금 더 풀어서 설명하자면&lt;/p&gt;

&lt;p&gt;우선 A.B.C.D 를 각각 옥텟(=8비트, 1바이트)이라고 부르며 192.168.0.0을 8비트로 변환해서 써보면,&lt;/p&gt;

&lt;p&gt;11000000.10101000.00000000.00000000 일것이다. 맨 왼쪽부터 24비트 이후에 오는 비트들을 사용할 수 있다 라는 의미는, 3번째 옥텟 이후 4번째 옥텟부터 전부 사용할 수 있다는 의미이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1번옥텟(8비트).2번옥텟(8비트).3번옥텟(8비트) «여기서부터 24비트 이후!» .4번옥텟(8비트)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 4번째 옥텟을 전부 이용하면 2^8을 전부 다 사용할 수 있다는 의미고 0~255 까지 전부 사용할 수 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.0/24 =&amp;gt; 192.168.0.0 ~ 192.168.0.255&lt;/code&gt; 까지를 나타낸 것이다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Network" /><summary type="html">IP 주소를 묶는 방법, CIDR란?</summary></entry><entry><title type="html">[Kubernetes] Kubernetes CNI</title><link href="https://hoex5h.github.io/Kubernetes-_Kubernetes_CNI" rel="alternate" type="text/html" title="[Kubernetes] Kubernetes CNI" /><published>2025-01-14T02:40:00+00:00</published><updated>2025-01-14T02:40:00+00:00</updated><id>https://hoex5h.github.io/%5BKubernetes%5D_Kubernetes_CNI</id><content type="html" xml:base="https://hoex5h.github.io/Kubernetes-_Kubernetes_CNI">&lt;h1 id=&quot;kubernetes-kubernetes-cni&quot;&gt;[Kubernetes] Kubernetes CNI&lt;/h1&gt;

&lt;h2 id=&quot;쿠버네티스-클러스터-네트워킹의-두-가지-원칙&quot;&gt;쿠버네티스 클러스터 네트워킹의 두 가지 원칙&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/&quot;&gt;쿠버네티스의 공식 문서&lt;/a&gt;를 참조해서 CNI 가 무엇인지, 어떠한 역할을 하는지 알아보자. 참고로 한국어로 번역된 페이지도 생각보다 많으니 공식 문서에서 한국어가 지원되는 페이지인지 확인해보는 것도 좋다.&lt;/p&gt;

&lt;p&gt;쿠버네티스 클러스터의 네트워킹에서는 반드시 지켜야 하는 두 가지 원칙이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 노드에 있는 파드와, 다른 모든 노드에 있는 모든 파드들과 물리적으로 통신할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;임의의 노드에 있는 파드와, 같은 노드에 있는 모든 파드들과 물리적으로 통신할 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번의 경우, 같은 노드에 있는 파드들은 같은 네임스페이스를 공유하기 때문에 로컬 호스트로 각각 컨테이너에 할당된 포트로 통신이 가능하다.&lt;/p&gt;

&lt;p&gt;같은 노드에 있는 A pod(8080) 와 B pod(7070) 은 서로 로컬호스트 포트로 통신이 가능하다는 뜻이다.&lt;/p&gt;

&lt;p&gt;그렇다면 1번 원칙은 어떻게 될까?&lt;/p&gt;

&lt;p&gt;뜬금없지만 사실 쿠버네티스 내부에는 네트워크가 구현되어 있지 않다. 위에서 언급했던 원칙처럼 어떻게 통신이 이루어져야 하는지에 대한 사양만 있고, 직접 구현되어 있지는 않다.&lt;/p&gt;

&lt;p&gt;사용자가 자신의 환경을 고려해서 적절한 네트워크 플러그인을 가져다 써야하는데, 이때 사용하는 네트워크 스펙 인터페이스가 CNI 이다.&lt;/p&gt;

&lt;h2 id=&quot;cni가-뭘까&quot;&gt;CNI가 뭘까?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/containernetworking/cni&quot;&gt;CNI Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CNI 공식 깃허브 문서에 따르면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CNI(Container Network Interface)는 리눅스 컨테이너에서 네트워크 인터페이스를 구성하기 위한 플러그인을 작성하는 사양(specification)과 라이브러리로 구성된 프로젝트이다. CNI는 오직 컨테이너간 네트워크 연결과 컨테이너가 삭제될 때, 할당된 리소스들을 지우는 것에만 관여한다. 이러한 점들 때문에, CNI는 넓은 범위의 지원을 받으며 구현하기 간단한 사양을 가지고 있다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;CNI는 리눅스 컨테이너의 네트워크 인터페이스를 관리할 수 있는 사양(specification)에 대한 프로젝트다. 컨테이너가 생성되고 삭제될 때, 네트워크 인터페이스가 생성되고 삭제되는 것을 어떻게 처리할 것인지에 대한 내용을 포함하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;cni는-그럼-왜-필요할까&quot;&gt;CNI는 그럼 왜 필요할까?&lt;/h2&gt;

&lt;p&gt;네트워크에 대한 구성은 인프라 환경에 따라서 구성이 매우 복잡하고 다양하다. 이렇게 다양한 네트워크 환경에서 수 많은 문제점들이 발생할 수 있는데, 이 수많은 문제점들에 대한 해결 방법도 천차만별이다. 결국 환경에 따라 네트워크 구성이 점점 복잡해지고 획일화되기는 쉽지 않게 될 것이다.&lt;/p&gt;

&lt;p&gt;CNI는 이렇게 네트워크 구성과 문제점이 복잡해지는 것을 막기 위해서 등장했다. 컨테이너 네트워크와 관련된 표준 스펙을 정의하고 있는 CNI를 통해서 네트워크를 구성하게 된다면 복잡했던 네트워크 구성과 문제점들을 어느정도 일축시킬 수 있을 것이다.&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-cni&quot;&gt;Kubernetes CNI&lt;/h2&gt;

&lt;p&gt;그 중에서 쿠버네티스를 위한 대표적인 플러그인들에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Calico, Flannel, Cilium ...&lt;/code&gt; 등이 있다. 더 자세한 내용은 &lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/cluster-administration/addons/#network-and-networking-policy&quot;&gt;쿠버네티스 네트워킹 애드온&lt;/a&gt; 을 참고하자.&lt;/p&gt;

&lt;h2 id=&quot;calico&quot;&gt;Calico&lt;/h2&gt;

&lt;p&gt;우리는 이번 기회에 Calico CNI 를 사용해볼 예정이기 때문에, Calico 에 대해 조금 자세히 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.tigera.io/calico/latest/about/&quot;&gt;What is Calico?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;버전이 올라가면서 Calico 공식문서 및 깃허브 링크가 바뀌는 경우가 있다. 기존의 프로젝트에서 떼어져 나온다든지, 이러한 이유들이 있는걸로 보인다.&lt;/p&gt;

&lt;h3 id=&quot;what-is-calico&quot;&gt;What is Calico&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;쿠버네티스에서는 기본적으로 파드 간 통신에 대한 기본 설정은 모두 허용(default-allow)이다. 네트워크 정책을 이용해서 이를 제한하지 않는다면, 모든 파드들은 다른 파드들과 제약없이 통신할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Calico 는 네트워크 통신을 보호하는 네트워킹과 cloud-native 의 마이크로서비스/애플리케이션을 보호하기 위한 고급 네트워크 정책으로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;Calico CNI는 containers, Kubernetes clusters, virtual machines, and native host-based workloads 를 보호하는 L3/L4 네트워킹 솔루션으로,  여러 데이터플레인을 프로그래밍하는 컨트롤 플레인이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 플레인 : 데이터 패킷이 이동하는 부분으로 실제로 사용자 또는 시스템 간에 데이터를 전송하는 역할을 담당하는 플레인. 데이터 패킷을 처리하고, 패킷의 다음 목적지로 전달하는 실질적인 처리와 전송을 담당하는 플레인 (근육)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;컨트롤 플레인 : 네트워크 경로를 결정하고, 정책을 설정하는 등의 네트워크 운영을 총괄하는 플레인. 네트워킹 장비에게 어떤 경로로 데이터 패킷을 전달해야 하는지 라우팅을 생성하고 관리하는 기능을 담당하는 플레인 (손,발)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-14-[Kubernetes]_Kubernetes_CNI.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CICD&quot;]" /><category term="[&quot;CICD&quot;]" /><category term="CICD" /><category term="Kubernetes" /><summary type="html">[Kubernetes] Kubernetes CNI</summary></entry></feed>